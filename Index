

require('dotenv').config();

const path = require('path');
const os = require('os');
const axios = require('axios');

const bs58pkg = require('bs58');
const bs58 = bs58pkg.default || bs58pkg;

const { Telegraf, Markup } = require('telegraf');
const Database = require('better-sqlite3');

const {
  Connection,
  PublicKey,
  Keypair,
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
} = require('@solana/web3.js');

/* =========================
   CONFIG
========================= */
const BOT_TOKEN = (process.env.BOT_TOKEN || '').trim();
const CHANNEL_ID_RAW = String((process.env.CHANNEL_ID || '').trim());
const RPC_URL = (process.env.RPC_URL || 'https://api.mainnet-beta.solana.com').trim();

const CHANNEL_LINK = (process.env.CHANNEL_LINK || '').trim();
const TWITTER_LINK = (process.env.TWITTER_LINK || '').trim();

const PAYOUT_SECRET_BASE58 = (process.env.PAYOUT_SECRET_BASE58 || '').trim();
const FEE_WALLET = (process.env.FEE_WALLET || '').trim();

const ADMIN_IDS = (process.env.ADMIN_IDS || '')
  .split(',')
  .map(x => x.trim())
  .filter(Boolean);

const BROADCAST_DELAY_MS = Number(process.env.BROADCAST_DELAY_MS || 450);
const META_REFRESH_MS = Number(process.env.META_REFRESH_MS || 90_000);
const HTTP_TIMEOUT_MS = Number(process.env.HTTP_TIMEOUT_MS || 15_000);

const MIN_HOLDER_PCT = Number(process.env.MIN_HOLDER_PCT || 0.0004);
const MIN_HOLD_HOURS = Number(process.env.MIN_HOLD_HOURS || 24);
const DAILY_PAYOUT_PCT = Number(process.env.DAILY_PAYOUT_PCT || 0.20);

const MIN_PAYOUT_SOL = Number(process.env.MIN_PAYOUT_SOL || 0.00001);
const MAX_PAYOUTS_PER_ROUND = Number(process.env.MAX_PAYOUTS_PER_ROUND || 300);
const MAX_PAYOUT_RECIPIENTS = Number(process.env.MAX_PAYOUT_RECIPIENTS || 80);
const TX_DELAY_MS = Number(process.env.TX_DELAY_MS || 350);
const PAYOUT_WALLET_BUFFER_LAMPORTS = Number(process.env.PAYOUT_WALLET_BUFFER_LAMPORTS || 2_000_000);

// Performance & Retry config
const MAX_RETRIES = 3;
const RETRY_DELAY = 2000;
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

function normalizeChannelId(x) {
  const v = String(x || '').trim();
  if (!v) return '';
  if (v.startsWith('@')) return v;
  return v;
}

const CHANNEL_ID = normalizeChannelId(CHANNEL_ID_RAW);

if (!BOT_TOKEN || !CHANNEL_ID) {
  console.log('âŒ ERROR: Missing BOT_TOKEN or CHANNEL_ID in .env');
  process.exit(1);
}
if (!PAYOUT_SECRET_BASE58) {
  console.log('âŒ ERROR: Missing PAYOUT_SECRET_BASE58 in .env');
  process.exit(1);
}
if (!FEE_WALLET) {
  console.log('âŒ ERROR: Missing FEE_WALLET in .env');
  process.exit(1);
}

/* =========================
   SOLANA
========================= */
let payer;
try {
  const secret = bs58.decode(PAYOUT_SECRET_BASE58);
  payer = Keypair.fromSecretKey(secret);
} catch {
  console.log('âŒ ERROR: PAYOUT_SECRET_BASE58 is invalid.');
  process.exit(1);
}

const REWARD_WALLET = payer.publicKey.toBase58();
const connection = new Connection(RPC_URL, 'confirmed');
const bot = new Telegraf(BOT_TOKEN);

/* =========================
   DATABASE
========================= */
const dbPath = (process.env.DB_PATH && process.env.DB_PATH.trim())
  ? process.env.DB_PATH.trim()
  : path.join(os.tmpdir(), 'whitememe.db');

const db = new Database(dbPath);
db.pragma('journal_mode = WAL');
db.pragma('synchronous = NORMAL');
db.pragma('busy_timeout = 8000');

console.log('ðŸ’¾ Database Path:', dbPath);
console.log('ðŸ“¢ Channel ID:', CHANNEL_ID);
console.log('ðŸ’° Reward Wallet:', REWARD_WALLET);

/* =========================
   DATABASE SCHEMA + MIGRATION
========================= */
db.exec(`
CREATE TABLE IF NOT EXISTS tokens (
  ca TEXT PRIMARY KEY,
  creator_tg_id INTEGER NOT NULL,
  creator_username TEXT,
  status TEXT NOT NULL DEFAULT 'PENDING_CONFIRM',
  created_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS token_meta (
  ca TEXT PRIMARY KEY,
  name TEXT,
  symbol TEXT,
  pump_url TEXT,
  dex_url TEXT,
  pair_address TEXT,
  on_dex_at_reg INTEGER DEFAULT 0,
  bonded_posted INTEGER DEFAULT 0,
  base_mc REAL DEFAULT 0,
  last_x_posted INTEGER DEFAULT 0,
  last_mc REAL DEFAULT 0,
  last_checked_at INTEGER DEFAULT 0,
  logo_url TEXT,
  display_name TEXT,
  display_symbol TEXT
);

-- NEUE TABELLE: Creator-Pools fÃ¼r jeden Creator-Token
CREATE TABLE IF NOT EXISTS creator_token_pools (
  creator_tg_id INTEGER NOT NULL,
  token_ca TEXT NOT NULL,
  sol_amount REAL NOT NULL DEFAULT 0,
  last_updated INTEGER NOT NULL,
  PRIMARY KEY (creator_tg_id, token_ca)
);

-- NEUE TABELLE: Creator-Payouts fÃ¼r Tracking
CREATE TABLE IF NOT EXISTS creator_payouts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  creator_tg_id INTEGER NOT NULL,
  token_ca TEXT NOT NULL,
  holder_wallet TEXT NOT NULL,
  sol_amount REAL NOT NULL,
  paid_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS deposits (
  signature TEXT PRIMARY KEY,
  ca TEXT NOT NULL,
  from_wallet TEXT,
  sol_amount REAL NOT NULL,
  fee_sol REAL NOT NULL,
  reward_sol REAL NOT NULL,
  fee_sig TEXT,
  created_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS payouts (
  payout_sig TEXT PRIMARY KEY,
  ca TEXT NOT NULL,
  to_wallet TEXT NOT NULL,
  sol_amount REAL NOT NULL,
  created_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS holders (
  ca TEXT NOT NULL,
  tg_id INTEGER NOT NULL,
  username TEXT,
  wallet TEXT NOT NULL,
  registered_at INTEGER NOT NULL,
  last_notified_at INTEGER DEFAULT 0,
  last_notification_type TEXT,
  total_paid REAL DEFAULT 0,
  last_paid_at INTEGER DEFAULT 0,
  PRIMARY KEY (ca, wallet)
);

CREATE TABLE IF NOT EXISTS groups (
  chat_id TEXT PRIMARY KEY,
  title TEXT,
  active INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  last_error TEXT
);

CREATE TABLE IF NOT EXISTS settings (
  k TEXT PRIMARY KEY,
  v TEXT
);
`);

function tableHasColumn(table, col) {
  const rows = db.prepare(`PRAGMA table_info(${table})`).all();
  return rows.some(r => r.name === col);
}

function addColumnIfMissing(table, col, defSql) {
  if (!tableHasColumn(table, col)) {
    db.exec(`ALTER TABLE ${table} ADD COLUMN ${col} ${defSql}`);
    console.log(`ðŸ”§ DB MIGRATION: added ${table}.${col}`);
  }
}

addColumnIfMissing('token_meta', 'on_dex_at_reg', 'INTEGER DEFAULT 0');
addColumnIfMissing('token_meta', 'bonded_posted', 'INTEGER DEFAULT 0');
addColumnIfMissing('token_meta', 'base_mc', 'REAL DEFAULT 0');
addColumnIfMissing('token_meta', 'last_x_posted', 'INTEGER DEFAULT 0');
addColumnIfMissing('token_meta', 'last_mc', 'REAL DEFAULT 0');
addColumnIfMissing('token_meta', 'last_checked_at', 'INTEGER DEFAULT 0');
addColumnIfMissing('token_meta', 'logo_url', 'TEXT');
addColumnIfMissing('token_meta', 'display_name', 'TEXT');
addColumnIfMissing('token_meta', 'display_symbol', 'TEXT');
addColumnIfMissing('groups', 'last_error', 'TEXT');
addColumnIfMissing('holders', 'last_notified_at', 'INTEGER DEFAULT 0');
addColumnIfMissing('holders', 'last_notification_type', 'TEXT');
addColumnIfMissing('holders', 'total_paid', 'REAL DEFAULT 0');
addColumnIfMissing('holders', 'last_paid_at', 'INTEGER DEFAULT 0');

/* =========================
   AUTO MIGRATION SYSTEM - NEU!
========================= */
function runAutoMigration() {
  console.log('ðŸ”§ Running auto-migration checks...');
  
  try {
    // 1. Check if deposits table has creator_tg_id column
    const depositsColumns = db.prepare(`
      SELECT name FROM pragma_table_info('deposits')
    `).all();
    
    const hasCreatorTgId = depositsColumns.some(col => col.name === 'creator_tg_id');
    
    if (!hasCreatorTgId) {
      console.log('âš ï¸ deposits table missing creator_tg_id column - adding it now...');
      
      db.exec(`
        ALTER TABLE deposits ADD COLUMN creator_tg_id INTEGER;
      `);
      
      // Update existing deposits with creator info
      db.exec(`
        UPDATE deposits 
        SET creator_tg_id = (
          SELECT creator_tg_id FROM tokens WHERE tokens.ca = deposits.ca
        )
        WHERE creator_tg_id IS NULL;
      `);
      
      console.log('âœ… Added creator_tg_id to deposits table and updated existing records');
    } else {
      console.log('âœ… deposits table has creator_tg_id column');
    }
    
    // 2. Check if payouts table has creator_tg_id column
    const payoutsColumns = db.prepare(`
      SELECT name FROM pragma_table_info('payouts')
    `).all();
    
    const hasPayoutsCreatorTgId = payoutsColumns.some(col => col.name === 'creator_tg_id');
    
    if (!hasPayoutsCreatorTgId) {
      console.log('âš ï¸ payouts table missing creator_tg_id column - adding it now...');
      
      db.exec(`
        ALTER TABLE payouts ADD COLUMN creator_tg_id INTEGER;
      `);
      
      // Update existing payouts with creator info
      db.exec(`
        UPDATE payouts 
        SET creator_tg_id = (
          SELECT creator_tg_id FROM tokens WHERE tokens.ca = payouts.ca
        )
        WHERE creator_tg_id IS NULL;
      `);
      
      console.log('âœ… Added creator_tg_id to payouts table and updated existing records');
    } else {
      console.log('âœ… payouts table has creator_tg_id column');
    }
    
    // 3. Migrate existing data to creator_token_pools
    console.log('ðŸ”„ Migrating existing data to creator_token_pools...');
    const tokens = db.prepare(`SELECT ca, creator_tg_id FROM tokens`).all();
    let migratedCount = 0;
    let totalMigratedSOL = 0;
    
    for (const token of tokens) {
      try {
        // Calculate total deposited for this creator/token
        const totalDeposited = db.prepare(`
          SELECT COALESCE(SUM(reward_sol),0) as total 
          FROM deposits 
          WHERE ca=? 
          AND (creator_tg_id=? OR creator_tg_id IS NULL OR creator_tg_id = '')
        `).get(token.ca, token.creator_tg_id);
        
        // Calculate total paid out for this creator/token
        const totalPaid = db.prepare(`
          SELECT COALESCE(SUM(p.sol_amount),0) as total 
          FROM payouts p
          JOIN tokens t ON p.ca = t.ca
          WHERE p.ca=? AND t.creator_tg_id=?
        `).get(token.ca, token.creator_tg_id);
        
        const remaining = Number(totalDeposited?.total || 0) - Number(totalPaid?.total || 0);
        
        if (remaining > 0) {
          // Check if pool already exists
          const existingPool = db.prepare(`
            SELECT sol_amount FROM creator_token_pools 
            WHERE creator_tg_id=? AND token_ca=?
          `).get(token.creator_tg_id, token.ca);
          
          if (!existingPool) {
            db.prepare(`
              INSERT INTO creator_token_pools 
              (creator_tg_id, token_ca, sol_amount, last_updated)
              VALUES (?, ?, ?, ?)
            `).run(token.creator_tg_id, token.ca, remaining, Date.now());
            
            migratedCount++;
            totalMigratedSOL += remaining;
            console.log(`   Migrated ${remaining.toFixed(4)} SOL to creator ${token.creator_tg_id} for token ${token.ca.slice(0, 8)}...`);
          }
        }
      } catch (err) {
        console.log(`   âš ï¸ Error migrating token ${token.ca.slice(0, 8)}...: ${err.message}`);
      }
    }
    
    console.log(`âœ… Migration completed: ${migratedCount} creator pools updated, total ${totalMigratedSOL.toFixed(4)} SOL migrated`);
    
    // 4. Create indexes for better performance
    console.log('âš¡ Creating performance indexes...');
    
    const indexes = [
      'CREATE INDEX IF NOT EXISTS idx_deposits_ca_creator ON deposits(ca, creator_tg_id)',
      'CREATE INDEX IF NOT EXISTS idx_payouts_ca_creator ON payouts(ca, creator_tg_id)',
      'CREATE INDEX IF NOT EXISTS idx_creator_pools_creator_token ON creator_token_pools(creator_tg_id, token_ca)',
      'CREATE INDEX IF NOT EXISTS idx_creator_payouts_creator_token ON creator_payouts(creator_tg_id, token_ca)',
      'CREATE INDEX IF NOT EXISTS idx_holders_ca_wallet ON holders(ca, wallet)',
      'CREATE INDEX IF NOT EXISTS idx_tokens_creator ON tokens(creator_tg_id)',
      'CREATE INDEX IF NOT EXISTS idx_token_meta_ca ON token_meta(ca)'
    ];
    
    for (const indexSql of indexes) {
      try {
        db.exec(indexSql);
      } catch (e) {
        // Ignore duplicate index errors
      }
    }
    
    console.log('âœ… Performance indexes created');
    
  } catch (error) {
    console.log('âš ï¸ Auto-migration error:', error.message);
    console.log('ðŸ’¡ Continuing bot startup...');
  }
}

/* =========================
   HELPER FUNCTIONS
========================= */
const now = () => Date.now();

async function withRetry(fn, context = '', retries = MAX_RETRIES) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      console.log(`ðŸ”„ Retry ${i + 1}/${retries} for ${context}:`, error.message);
      if (i === retries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * (i + 1)));
    }
  }
}

function isAdmin(ctx) {
  return ADMIN_IDS.includes(String(ctx.from?.id || ''));
}

function isValidPubkey(s) {
  try { new PublicKey((s || '').trim()); return true; } catch { return false; }
}

function extractFirstPubkey(text) {
  const t = (text || '').trim();
  if (!t) return null;
  const parts = t.split(/\s+/g).filter(Boolean);
  for (const p of parts) if (isValidPubkey(p)) return p;
  const m = t.match(/[1-9A-HJ-NP-Za-km-z]{32,60}/g);
  if (m) for (const cand of m) if (isValidPubkey(cand)) return cand;
  return null;
}

function extractSignatureFromText(text) {
  const t = (text || '').trim();
  const m = t.match(/solscan\.io\/tx\/([A-Za-z0-9]+)/i);
  if (m?.[1]) return m[1];
  if (/^[A-Za-z0-9]{50,120}$/.test(t)) return t;
  return null;
}

function fmtSol(x) {
  return Number(x || 0).toFixed(4);
}

function pumpfunLink(tokenCA) { return `https://pump.fun/${tokenCA}`; }
function dexscreenerTokenLink(tokenCA) { return `https://dexscreener.com/solana/${tokenCA}`; }

function dbGetSetting(k, fallback = null) {
  const r = db.prepare(`SELECT v FROM settings WHERE k=?`).get(k);
  return r?.v ?? fallback;
}

function dbSetSetting(k, v) {
  db.prepare(`INSERT INTO settings (k,v) VALUES (?,?) ON CONFLICT(k) DO UPDATE SET v=excluded.v`)
    .run(k, String(v));
}

function getActiveGroups() {
  return db.prepare(`SELECT chat_id FROM groups WHERE active=1`).all().map(r => String(r.chat_id));
}

function disableGroup(chatId, reason) {
  db.prepare(`UPDATE groups SET active=0, last_error=? WHERE chat_id=?`).run(String(reason || ''), String(chatId));
}

async function safeAnswerCb(ctx) { 
  try { 
    await ctx.answerCbQuery(); 
  } catch (e) {
    console.log('âŒ Error answering callback:', e.message);
  }
}

function tgErrSummary(e) {
  const code = e?.code;
  const desc = e?.description;
  const msg = e?.message || '';
  return `code=${code || 'n/a'} desc=${desc || 'n/a'} msg=${msg || 'n/a'}`;
}

// Format Market Cap function - FIXED!
function formatMc(mc) {
  const x = Number(mc || 0);
  if (!x) return 'N/A';
  if (x >= 1e9) return `${(x / 1e9).toFixed(2)}B`;
  if (x >= 1e6) return `${(x / 1e6).toFixed(2)}M`;
  if (x >= 1e3) return `${(x / 1e3).toFixed(2)}K`;
  return `${x.toFixed(0)}`;
}

/* =========================
   DM NOTIFICATION FUNCTIONS
========================= */
async function sendPayoutDM(holderTgId, tokenCA, payoutAmount, wallet, signature) {
  try {
    const meta = getMeta(tokenCA);
    const tokenName = meta?.display_name || meta?.name || tokenCA.slice(0, 8);
    
    const dmText = `ðŸŽ‰ WHITEMEME REWARD PAYOUT! ðŸŽ‰

ðŸ’° You received: ${fmtSol(payoutAmount)} SOL
ðŸ“Š Token: ${tokenName}
ðŸ‘› Your wallet: ${wallet.slice(0, 8)}...${wallet.slice(-4)}
ðŸ“… Payout date: ${new Date().toLocaleDateString()}
ðŸ”— Transaction: ${signature.slice(0, 16)}...

âœ… Thank you for holding!
â° Keep holding for more rewards! ðŸš€`;

    await bot.telegram.sendMessage(holderTgId, dmText);
    console.log(`ðŸ“¨ Payout DM sent to ${holderTgId}: ${fmtSol(payoutAmount)} SOL`);
    return true;
  } catch (error) {
    console.log(`âŒ Failed to send payout DM to ${holderTgId}:`, error.message);
    return false;
  }
}

async function sendRegistrationDM(holderTgId, tokenCA, wallet, balance, supplyUi) {
  try {
    const meta = getMeta(tokenCA);
    const tokenName = meta?.display_name || meta?.name || tokenCA.slice(0, 8);
    const tokenSymbol = meta?.display_symbol || meta?.symbol || 'N/A';
    
    const holderPct = supplyUi > 0 ? (balance / supplyUi * 100).toFixed(6) : '0';
    const requiredPct = (MIN_HOLDER_PCT * 100).toFixed(4);
    
    const dmText = `âœ… WHITEMEME HOLDER REGISTERED!

ðŸ“Š Token: ${tokenName} #${tokenSymbol}
ðŸ‘› Your wallet: ${wallet.slice(0, 8)}...${wallet.slice(-4)}
ðŸ“… Registered: ${new Date().toLocaleDateString()}
ðŸ” Your balance: ${balance.toFixed(4)} tokens

ðŸ“ˆ Eligibility Status:
âœ“ Minimum holding: ${requiredPct}% âœ… (you have ${holderPct}%)
â° Hold time: 0/${MIN_HOLD_HOURS} hours
ðŸ’° Estimated daily reward: ~${fmtSol(balance / supplyUi * 100)} SOL

âœ… You will receive automatic payouts!`;

    await bot.telegram.sendMessage(holderTgId, dmText);
    console.log(`ðŸ“¨ Registration DM sent to ${holderTgId} for ${tokenName}`);
    return true;
  } catch (error) {
    console.log(`âŒ Failed to send registration DM to ${holderTgId}:`, error.message);
    return false;
  }
}

async function sendEligibilityDM(holderTgId, tokenCA, holdHours) {
  try {
    const meta = getMeta(tokenCA);
    const tokenName = meta?.display_name || meta?.name || tokenCA.slice(0, 8);
    const tokenSymbol = meta?.display_symbol || meta?.symbol || 'N/A';
    
    const dmText = `ðŸ“Š WHITEMEME ELIGIBILITY UPDATE

ðŸŽ¯ Token: ${tokenName} #${tokenSymbol}
âœ… You are NOW ELIGIBLE for rewards!
â° Hold time: ${holdHours.toFixed(1)}/${MIN_HOLD_HOURS} hours âœ…
ðŸ“Š Your share: Calculated based on your holdings
ðŸ’° Next payout: Today 20:00 UTC

ðŸŽ‰ Congratulations! Keep holding for rewards!`;

    await bot.telegram.sendMessage(holderTgId, dmText);
    console.log(`ðŸ“¨ Eligibility DM sent to ${holderTgId} for ${tokenName}`);
    return true;
  } catch (error) {
    console.log(`âŒ Failed to send eligibility DM to ${holderTgId}:`, error.message);
    return false;
  }
}

/* =========================
   SOLANA HELPER FUNCTIONS
========================= */
async function getMintSupplyAndDecimals(mint) {
  return await withRetry(async () => {
    const pk = new PublicKey(mint);
    const supply = await connection.getTokenSupply(pk, 'confirmed');
    const decimals = Number(supply?.value?.decimals ?? 0);
    const amount = Number(supply?.value?.amount ?? 0);
    const uiAmount = Number(supply?.value?.uiAmount ?? 0);
    return { decimals, rawAmount: amount, uiAmount };
  }, 'getMintSupplyAndDecimals');
}

async function getWalletTokenBalanceUi(wallet, mint) {
  return await withRetry(async () => {
    const owner = new PublicKey(wallet);
    const m = new PublicKey(mint);
    const res = await connection.getParsedTokenAccountsByOwner(owner, { mint: m }, 'confirmed');
    let total = 0;
    for (const acc of res.value || []) {
      const ui = acc.account?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
      total += Number(ui || 0);
    }
    return total;
  }, 'getWalletTokenBalanceUi');
}

/* =========================
   CREATOR POOL FUNCTIONS (NEUE FUNKTIONEN)
========================= */
function getCreatorTokenPool(creatorId, tokenCA) {
  const row = db.prepare(`
    SELECT sol_amount FROM creator_token_pools 
    WHERE creator_tg_id=? AND token_ca=?
  `).get(creatorId, tokenCA);
  return Number(row?.sol_amount || 0);
}

function getCreatorTotalPool(creatorId) {
  const rows = db.prepare(`
    SELECT sol_amount FROM creator_token_pools 
    WHERE creator_tg_id=?
  `).all(creatorId);
  
  let total = 0;
  rows.forEach(row => total += Number(row.sol_amount || 0));
  return total;
}

function updateCreatorTokenPool(creatorId, tokenCA, amount) {
  db.prepare(`
    INSERT INTO creator_token_pools (creator_tg_id, token_ca, sol_amount, last_updated)
    VALUES (?, ?, ?, ?)
    ON CONFLICT(creator_tg_id, token_ca) DO UPDATE SET
      sol_amount = sol_amount + excluded.sol_amount,
      last_updated = excluded.last_updated
  `).run(creatorId, tokenCA, amount, now());
}

function getCreatorTokenStats(creatorId, tokenCA) {
  const pool = getCreatorTokenPool(creatorId, tokenCA);
  const totalDeposited = db.prepare(`
    SELECT COALESCE(SUM(reward_sol),0) as total 
    FROM deposits 
    WHERE ca=? AND creator_tg_id=?
  `).get(tokenCA, creatorId);
  
  const totalPaid = db.prepare(`
    SELECT COALESCE(SUM(sol_amount),0) as total 
    FROM creator_payouts 
    WHERE creator_tg_id=? AND token_ca=?
  `).get(creatorId, tokenCA);
  
  return {
    pool: Number(pool || 0),
    totalDeposited: Number(totalDeposited?.total || 0),
    totalPaid: Number(totalPaid?.total || 0)
  };
}

/* =========================
   PAYOUT HELPER FUNCTIONS (AKTUALISIERT)
========================= */
function getPayoutEligibility(tokenCA, wallet, balance) {
  const holder = db.prepare(`SELECT registered_at, tg_id FROM holders WHERE ca=? AND wallet=?`).get(tokenCA, wallet);
  if (!holder) return { eligible: false, reason: 'not_registered' };
  
  const registeredAt = Number(holder.registered_at || 0);
  const holdHours = (now() - registeredAt) / (1000 * 60 * 60);
  
  if (holdHours < MIN_HOLD_HOURS) {
    return { 
      eligible: false, 
      reason: 'hold_time', 
      hours: holdHours,
      required: MIN_HOLD_HOURS,
      tg_id: holder.tg_id
    };
  }
  
  const token = getToken(tokenCA);
  if (!token || token.status !== 'ACTIVE') {
    return { eligible: false, reason: 'token_inactive', tg_id: holder.tg_id };
  }
  
  return { eligible: true, holdHours, tg_id: holder.tg_id };
}

async function calculatePayoutsForToken(tokenCA) {
  // WICHTIG: Hole nur den Pool vom jeweiligen Creator
  const token = getToken(tokenCA);
  if (!token) {
    return { totalPayout: 0, recipients: [], message: 'Token not found' };
  }
  
  const creatorId = token.creator_tg_id;
  const creatorPool = getCreatorTokenPool(creatorId, tokenCA);
  
  // Nur den Creator-Pool verwenden, nicht den Gesamtpool
  const pool = creatorPool;
  
  if (pool < MIN_PAYOUT_SOL) {
    return { 
      totalPayout: 0, 
      recipients: [], 
      message: `Creator pool too small: ${fmtSol(pool)} SOL < ${fmtSol(MIN_PAYOUT_SOL)} SOL minimum` 
    };
  }
  
  const holders = db.prepare(`
    SELECT h.wallet, h.registered_at, h.tg_id
    FROM holders h 
    WHERE h.ca=? 
    ORDER BY h.registered_at ASC
    LIMIT ${MAX_PAYOUT_RECIPIENTS}
  `).all(tokenCA);
  
  if (!holders.length) {
    return { totalPayout: 0, recipients: [], message: 'No holders registered' };
  }
  
  let supplyUi = 0;
  try {
    const supply = await getMintSupplyAndDecimals(tokenCA);
    supplyUi = Number(supply.uiAmount || 0);
    console.log(`âœ… Token supply for ${tokenCA}: ${supplyUi}`);
  } catch (e) {
    console.log(`âŒ Error fetching supply for ${tokenCA}:`, e.message);
    return { totalPayout: 0, recipients: [], message: `Token supply unknown: ${e.message}` };
  }
  
  if (supplyUi <= 0) {
    return { totalPayout: 0, recipients: [], message: 'Token supply unknown or zero' };
  }
  
  const eligibleRecipients = [];
  let totalWeight = 0;
  
  for (const holder of holders) {
    try {
      const balance = await getWalletTokenBalanceUi(holder.wallet, tokenCA);
      
      if (balance <= 0) continue;
      
      const holderPct = balance / supplyUi;
      if (holderPct < MIN_HOLDER_PCT) continue;
      
      const eligibility = getPayoutEligibility(tokenCA, holder.wallet, balance);
      
      if (eligibility.eligible) {
        const holderWeight = balance / supplyUi;
        eligibleRecipients.push({
          wallet: holder.wallet,
          balance,
          weight: holderWeight,
          holdHours: eligibility.holdHours,
          holderPct: holderPct * 100,
          tg_id: holder.tg_id
        });
        totalWeight += holderWeight;
      }
    } catch (e) {
      console.log(`âŒ Error checking holder ${holder.wallet}:`, e.message);
    }
  }
  
  if (!eligibleRecipients.length) {
    return { totalPayout: 0, recipients: [], message: 'No eligible holders' };
  }
  
  const dailyPayoutAmount = pool * DAILY_PAYOUT_PCT;
  const actualPayoutAmount = Math.min(dailyPayoutAmount, pool);
  
  const payouts = [];
  let totalToPay = 0;
  let recipientsCount = 0;
  
  for (const recipient of eligibleRecipients) {
    if (recipientsCount >= MAX_PAYOUTS_PER_ROUND) break;
    
    const share = recipient.weight / totalWeight;
    const payoutAmount = actualPayoutAmount * share;
    
    if (payoutAmount >= MIN_PAYOUT_SOL) {
      payouts.push({
        wallet: recipient.wallet,
        amount: payoutAmount,
        share: share * 100,
        balance: recipient.balance,
        holdHours: recipient.holdHours,
        holderPct: recipient.holderPct,
        tg_id: recipient.tg_id
      });
      totalToPay += payoutAmount;
      recipientsCount++;
    }
  }
  
  return {
    totalPayout: totalToPay,
    recipients: payouts,
    pool,
    supplyUi,
    message: `Calculated ${payouts.length} payouts totaling ${fmtSol(totalToPay)} SOL`
  };
}

async function executePayoutsForToken(tokenCA) {
  const calculation = await calculatePayoutsForToken(tokenCA);
  
  if (calculation.totalPayout <= 0 || !calculation.recipients.length) {
    return {
      success: false,
      message: calculation.message,
      paid: 0,
      recipients: 0,
      transactions: []
    };
  }
  
  const payerBalance = await connection.getBalance(payer.publicKey);
  const requiredBalance = Math.ceil(calculation.totalPayout * LAMPORTS_PER_SOL + PAYOUT_WALLET_BUFFER_LAMPORTS);
  
  if (payerBalance < requiredBalance) {
    return {
      success: false,
      message: `Insufficient balance in payout wallet: ${fmtSol(payerBalance / LAMPORTS_PER_SOL)} SOL < ${fmtSol(requiredBalance / LAMPORTS_PER_SOL)} SOL required`,
      paid: 0,
      recipients: 0,
      transactions: []
    };
  }
  
  const transactions = [];
  let totalPaid = 0;
  let successfulRecipients = 0;
  const token = getToken(tokenCA);
  const creatorId = token.creator_tg_id;
  
  for (const payout of calculation.recipients) {
    try {
      const lamports = Math.floor(payout.amount * LAMPORTS_PER_SOL);
      if (lamports <= 0) continue;
      
      const to = new PublicKey(payout.wallet);
      const tx = new Transaction().add(
        SystemProgram.transfer({ 
          fromPubkey: payer.publicKey, 
          toPubkey: to, 
          lamports 
        })
      );
      
      const sig = await sendAndConfirmTransaction(connection, tx, [payer], { 
        commitment: 'confirmed',
        skipPreflight: false,
        preflightCommitment: 'confirmed'
      });
      
      // Save payout to database
      db.prepare(`
        INSERT INTO payouts (payout_sig, ca, to_wallet, sol_amount, created_at, creator_tg_id)
        VALUES (?, ?, ?, ?, ?, ?)
      `).run(sig, tokenCA, payout.wallet, payout.amount, now(), creatorId);
      
      // Save to creator_payouts table for tracking
      db.prepare(`
        INSERT INTO creator_payouts (creator_tg_id, token_ca, holder_wallet, sol_amount, paid_at)
        VALUES (?, ?, ?, ?, ?)
      `).run(creatorId, tokenCA, payout.wallet, payout.amount, now());
      
      // Update holder stats
      db.prepare(`
        UPDATE holders 
        SET total_paid = total_paid + ?, last_paid_at = ?
        WHERE ca=? AND wallet=?
      `).run(payout.amount, now(), tokenCA, payout.wallet);
      
      // WICHTIG: Creator-Pool reduzieren (nur dieser Creator!)
      db.prepare(`
        UPDATE creator_token_pools 
        SET sol_amount = sol_amount - ?, last_updated = ?
        WHERE creator_tg_id=? AND token_ca=?
      `).run(payout.amount, now(), creatorId, tokenCA);
      
      // Send DM notification to holder
      if (payout.tg_id) {
        await sendPayoutDM(payout.tg_id, tokenCA, payout.amount, payout.wallet, sig);
      }
      
      transactions.push({
        wallet: payout.wallet,
        amount: payout.amount,
        signature: sig,
        tg_id: payout.tg_id,
        success: true
      });
      
      totalPaid += payout.amount;
      successfulRecipients++;
      
      console.log(`âœ… Payout to ${payout.wallet.slice(0, 8)}...: ${fmtSol(payout.amount)} SOL (from creator ${creatorId} pool)`);
      
      await new Promise(resolve => setTimeout(resolve, TX_DELAY_MS));
      
    } catch (error) {
      console.log(`âŒ Payout failed to ${payout.wallet.slice(0, 8)}...:`, error.message);
      transactions.push({
        wallet: payout.wallet,
        amount: payout.amount,
        error: error.message,
        success: false
      });
    }
  }
  
  return {
    success: successfulRecipients > 0,
    message: `Executed ${successfulRecipients} payouts totaling ${fmtSol(totalPaid)} SOL (from creator ${creatorId} pool)`,
    paid: totalPaid,
    recipients: successfulRecipients,
    transactions,
    calculation
  };
}

async function manualPayoutAllTokens() {
  const activeTokens = db.prepare(`
    SELECT t.ca, t.creator_tg_id,
           COALESCE(tm.display_name, tm.name) as name,
           COALESCE(tm.display_symbol, tm.symbol) as symbol
    FROM tokens t
    LEFT JOIN token_meta tm ON tm.ca=t.ca
    WHERE t.status='ACTIVE'
  `).all();
  
  if (!activeTokens.length) {
    return { success: false, message: 'No active tokens found' };
  }
  
  const results = [];
  let totalPaidAll = 0;
  let totalRecipientsAll = 0;
  
  for (const token of activeTokens) {
    console.log(`ðŸ’° Processing payouts for token: ${token.name || token.ca} (creator: ${token.creator_tg_id})`);
    
    // Check if creator has pool for this token
    const creatorPool = getCreatorTokenPool(token.creator_tg_id, token.ca);
    if (creatorPool < MIN_PAYOUT_SOL) {
      console.log(`âš ï¸ Skipping ${token.ca}: Creator pool too small (${fmtSol(creatorPool)} SOL)`);
      continue;
    }
    
    const result = await executePayoutsForToken(token.ca);
    
    results.push({
      tokenCA: token.ca,
      tokenName: token.name || 'Unknown',
      tokenSymbol: token.symbol || 'N/A',
      creatorId: token.creator_tg_id,
      ...result
    });
    
    totalPaidAll += result.paid || 0;
    totalRecipientsAll += result.recipients || 0;
    
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
  
  return {
    success: totalPaidAll > 0,
    message: `Manual payout completed: ${totalRecipientsAll} recipients paid ${fmtSol(totalPaidAll)} SOL across ${results.length} tokens`,
    totalPaid: totalPaidAll,
    totalRecipients: totalRecipientsAll,
    results
  };
}

/* =========================
   BONDED POSTING & MILESTONE SYSTEM
========================= */
async function checkAndPostMilestones() {
  const activeTokens = db.prepare(`
    SELECT t.ca, tm.base_mc, tm.last_mc, tm.last_x_posted, tm.bonded_posted,
           COALESCE(tm.display_name, tm.name) as name,
           COALESCE(tm.display_symbol, tm.symbol) as symbol
    FROM tokens t
    LEFT JOIN token_meta tm ON tm.ca=t.ca
    WHERE t.status='ACTIVE' 
      AND tm.base_mc > 0 
      AND tm.last_mc > 0
  `).all();

  for (const token of activeTokens) {
    const currentMC = Number(token.last_mc || 0);
    const baseMC = Number(token.base_mc || 0);
    
    if (baseMC <= 0 || currentMC <= 0) continue;
    
    const multiplier = currentMC / baseMC;
    let milestone = 0;
    
    if (multiplier >= 10 && (!token.last_x_posted || token.last_x_posted < 10)) {
      milestone = 10;
    } else if (multiplier >= 5 && (!token.last_x_posted || token.last_x_posted < 5)) {
      milestone = 5;
    } else if (multiplier >= 2 && (!token.last_x_posted || token.last_x_posted < 2)) {
      milestone = 2;
    }
    
    if (milestone > 0) {
      db.prepare(`UPDATE token_meta SET last_x_posted=? WHERE ca=?`).run(milestone, token.ca);
      
      const isPumpFun = String(token.ca).toLowerCase().endsWith('pump');
      const meta = getMeta(token.ca);
      const isBonded = meta?.on_dex_at_reg === 1 && isPumpFun;
      
      await postMilestone(token.ca, milestone, isBonded);
      
      console.log(`ðŸ“ˆ ${isBonded ? 'Bonded' : 'Milestone'} Post: ${token.name} reached ${milestone}x`);
      
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
}

async function postMilestone(tokenCA, milestone, isBonded = false) {
  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const token = getToken(tokenCA);
  const creatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  const displayName = meta?.display_name || meta?.name || 'Token';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  const emojiMap = { 2: 'ðŸ’°', 5: 'ðŸš€', 10: 'ðŸ’Ž' };
  const emoji = emojiMap[milestone] || 'ðŸŽ‰';
  const emojiString = emoji.repeat(milestone);
  
  let caption = '';
  
  if (isBonded) {
    caption = `ðŸŽ—ï¸ BONDED POSTING ðŸš€

ðŸª™ Token: ${displayName} #${displaySymbol}
ðŸŽ¯ Status: BONDED TO DEX
ðŸ† Achievement: ${milestone}X FROM BOND!

Token successfully bonded and already ${milestone}X!
From Pump.fun to DEX success!

ðŸ’Ž Market Cap: ${formatMc(Number(meta?.last_mc || 0))}
ðŸ’° Creator Pool: ${fmtSol(creatorPool)} SOL

âœ… Bonded token - Fully launched!
â° Holders earning rewards

${emojiString}`;
  } else {
    caption = `ðŸ“ˆ MILESTONE UPDATE!

ðŸª™ Token: ${displayName} #${displaySymbol}
ðŸ† Achievement: ${milestone}X FROM LAUNCH!

Token has ${milestone}X'd from launch price! 
Great momentum building!

ðŸ’Ž Market Cap: ${formatMc(Number(meta?.last_mc || 0))}
ðŸ’° Creator Pool: ${fmtSol(creatorPool)} SOL

âœ… Holders earning automatic rewards
â° Minimum hold: ${MIN_HOLD_HOURS} hours

${emojiString}`;
  }

  try {
    const me = await bot.telegram.getMe();
    
    let buttons;
    const isPump = String(tokenCA).toLowerCase().endsWith('pump');
    if (isPump) {
      buttons = Markup.inlineKeyboard([
        [
          Markup.button.url('ðŸš€ Pump.fun', meta?.pump_url || pumpfunLink(tokenCA)),
          Markup.button.url('ðŸ“Š Chart', meta?.dex_url || dexscreenerTokenLink(tokenCA)),
        ],
        [Markup.button.url('ðŸ¤– Open WhiteMeme Bot', `https://t.me/${me.username}`)],
      ]);
    } else {
      buttons = Markup.inlineKeyboard([
        [
          Markup.button.url('ðŸ“Š Chart', meta?.dex_url || dexscreenerTokenLink(tokenCA)),
        ],
        [Markup.button.url('ðŸ¤– Open WhiteMeme Bot', `https://t.me/${me.username}`)],
      ]);
    }

    const img = meta?.logo_url || null;

    if (img) {
      broadcastToChannelAndGroups('sendPhoto', [img, { 
        caption, 
        reply_markup: buttons.reply_markup,
        parse_mode: 'Markdown'
      }], `(${isBonded ? 'bonded' : 'milestone'} ${milestone}x ${tokenCA.slice(0, 6)}...)`);
    } else {
      broadcastToChannelAndGroups('sendMessage', [caption, { 
        reply_markup: buttons.reply_markup,
        parse_mode: 'Markdown'
      }], `(${isBonded ? 'bonded' : 'milestone'} ${milestone}x ${tokenCA.slice(0, 6)}...)`);
    }

    console.log(`âœ… ${isBonded ? 'Bonded' : 'Milestone'} post queued for ${milestone}x: ${tokenCA}`);

  } catch (error) {
    console.log(`âŒ Error creating ${isBonded ? 'bonded' : 'milestone'} post: ${error.message}`);
  }
}

function startMilestoneChecker() {
  console.log('ðŸ“ˆ Starting Milestone Checker...');
  
  setInterval(async () => {
    try {
      const activeTokens = db.prepare(`
        SELECT ca FROM tokens WHERE status='ACTIVE'
      `).all();
      
      for (const token of activeTokens) {
        try {
          const pair = await fetchDexPair(token.ca);
          if (pair) {
            const mc = pairMarketCap(pair);
            if (mc > 0) {
              db.prepare(`UPDATE token_meta SET last_mc=?, last_checked_at=? WHERE ca=?`)
                .run(mc, now(), token.ca);
              
              const meta = getMeta(token.ca);
              if (!meta?.base_mc || Number(meta.base_mc) <= 0) {
                db.prepare(`UPDATE token_meta SET base_mc=? WHERE ca=?`).run(mc, token.ca);
              }
            }
          }
        } catch (e) {
          // Silent fail for individual tokens
        }
        
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      await checkAndPostMilestones();
      
    } catch (error) {
      console.log('âŒ Milestone checker error:', error.message);
    }
  }, META_REFRESH_MS);
}

/* =========================
   MONOSPACE FORMATTING
========================= */
function monospace(text) {
  return `\`${text}\``;
}

/* =========================
   CHAT CLEANUP
========================= */
async function cleanupPreviousMessage(ctx) {
  try {
    if (ctx.message && ctx.message.message_id) {
      await ctx.deleteMessage();
    }
  } catch (e) {}
}

async function cleanupAfterDelay(ctx, delayMs = 3000) {
  setTimeout(async () => {
    try {
      await ctx.deleteMessage();
    } catch (e) {}
  }, delayMs);
}

async function safeEditOrReply(ctx, text, keyboard = null, cleanupDelay = 0) {
  if (ctx.updateType === 'callback_query') {
    try {
      const msg = await ctx.editMessageText(text, keyboard ? { 
        reply_markup: keyboard.reply_markup,
        parse_mode: 'Markdown'
      } : { parse_mode: 'Markdown' });
      
      if (cleanupDelay > 0 && !text.includes('ðŸŽ­ WELCOME') && !text.includes('ðŸ‘¨â€ðŸŽ¨ Creator Panel') && !text.includes('ðŸ‘¥ Holder Panel') && !text.includes('âš¡ Admin Panel')) {
        cleanupAfterDelay(ctx, cleanupDelay);
      }
      return msg;
    } catch (e) {
      const msg = await ctx.reply(text, keyboard ? { 
        reply_markup: keyboard.reply_markup,
        parse_mode: 'Markdown'
      } : { parse_mode: 'Markdown' });
      
      if (cleanupDelay > 0) {
        cleanupAfterDelay(ctx, cleanupDelay);
      }
      return msg;
    }
  }
  
  const msg = await ctx.reply(text, keyboard ? { 
    reply_markup: keyboard.reply_markup,
    parse_mode: 'Markdown'
  } : { parse_mode: 'Markdown' });
  
  if (cleanupDelay > 0) {
    cleanupAfterDelay(ctx, cleanupDelay);
  }
  return msg;
}

/* =========================
   BROADCAST QUEUE
========================= */
const broadcastQueue = [];
let broadcastWorkerRunning = false;

function enqueueBroadcast(method, chatId, payload, tag = '') {
  broadcastQueue.push({ method, chatId: String(chatId), payload, tries: 0, tag });
}

async function startBroadcastWorker() {
  if (broadcastWorkerRunning) return;
  
  console.log('ðŸ“¢ STARTING Broadcast Worker...');
  broadcastWorkerRunning = true;

  while (broadcastWorkerRunning) {
    const job = broadcastQueue.shift();
    if (!job) { 
      await new Promise(r => setTimeout(r, 100)); 
      continue; 
    }

    console.log(`ðŸ“¢ Processing: ${job.method} -> ${job.chatId} (Queue: ${broadcastQueue.length})`);
    
    try {
      await new Promise(r => setTimeout(r, BROADCAST_DELAY_MS));
      await bot.telegram[job.method](job.chatId, ...job.payload);
      console.log(`ðŸ“¢ âœ… Success: ${job.method} -> ${job.chatId}`);
    } catch (e) {
      const summary = tgErrSummary(e);
      console.log(`ðŸ“¢ âŒ Error: ${job.method} -> ${job.chatId}: ${summary}`);

      const code = e?.code;
      const desc = String(e?.description || '');
      const hard =
        code === 403 ||
        (code === 400 && /chat not found|bot was kicked|forbidden|not enough rights/i.test(desc));

      if (hard && String(job.chatId).startsWith('-')) {
        disableGroup(job.chatId, `auto-disabled: ${desc || summary}`);
        console.log(`ðŸ“¢ Group disabled: ${job.chatId} Reason: ${desc || summary}`);
      }

      if (job.method === 'sendPhoto') {
        try {
          const photoArgs = job.payload;
          const opts = photoArgs?.[1] || {};
          const caption = String(opts.caption || '');
          const reply_markup = opts.reply_markup;
          enqueueBroadcast('sendMessage', job.chatId, [caption, { reply_markup, parse_mode: 'Markdown' }], '(fallback from photo)');
          continue;
        } catch {}
      }

      if (job.tries < 3 && /Too Many Requests|timeout|ECONNRESET|ETELEGRAM|EFATAL/i.test(String(e?.message || desc || ''))) {
        job.tries += 1;
        broadcastQueue.push(job);
        await new Promise(r => setTimeout(r, 1200));
      }
    }
  }
}

function broadcastToChannelAndGroups(method, payload, tag = '') {
  const targets = [String(CHANNEL_ID), ...getActiveGroups()];
  console.log(`ðŸ“¢ BROADCAST: ${targets.length} targets, Method=${method}, Tag=${tag}`);
  for (const chatId of targets) enqueueBroadcast(method, chatId, payload, tag);
}

/* =========================
   TOKEN DATA
========================= */
const metaCache = new Map();

async function fetchDexPair(tokenCA) {
  return await withRetry(async () => {
    const url = `https://api.dexscreener.com/latest/dex/tokens/${tokenCA}`;
    const res = await axios.get(url, { timeout: HTTP_TIMEOUT_MS });
    return res.data?.pairs?.[0] || null;
  }, 'fetchDexPair');
}

function pairMarketCap(pair) {
  const mc = Number(pair?.fdv ?? pair?.marketCap ?? 0);
  return Number.isFinite(mc) ? mc : 0;
}
function pairName(pair) { return pair?.baseToken?.name || null; }
function pairSymbol(pair) { return pair?.baseToken?.symbol || null; }
function pairAddress(pair) { return pair?.pairAddress || null; }
function pairLogo(pair) {
  return pair?.baseToken?.logoURI || pair?.info?.imageUrl || pair?.info?.imageUrl || null;
}

/* =========================
   Pump.fun META
========================= */
async function fetchPumpMeta(tokenCA) {
  return await withRetry(async () => {
    const url = pumpfunLink(tokenCA);
    const html = (await axios.get(url, { timeout: HTTP_TIMEOUT_MS })).data;

    const mImg = html.match(/property=["']og:image["'][^>]*content=["']([^"']+)["']/i);
    const img = (mImg?.[1] || '').trim() || null;

    const mTitle = html.match(/property=["']og:title["'][^>]*content=["']([^"']+)["']/i);
    const title = (mTitle?.[1] || '').trim();

    let name = null;
    let symbol = null;

    const mt = title.match(/^(.+?)\s*\((?:\$)?([A-Za-z0-9_]{1,15})\)\s*$/);
    if (mt) {
      name = mt[1]?.trim() || null;
      symbol = mt[2]?.trim() || null;
    } else if (title) {
      name = title.slice(0, 64);
    }

    return { ok: true, name, symbol, img, pump_url: url };
  }, 'fetchPumpMeta');
}

/* =========================
   META UPSERT WITH CACHE
========================= */
function upsertTokenMeta(tokenCA, fields) {
  const pump_url = pumpfunLink(tokenCA);
  const dex_url = dexscreenerTokenLink(tokenCA);

  db.prepare(`
    INSERT INTO token_meta (ca, name, symbol, pump_url, dex_url, pair_address, on_dex_at_reg, logo_url, display_name, display_symbol)
    VALUES (@ca, @name, @symbol, @pump_url, @dex_url, @pair_address, @on_dex_at_reg, @logo_url, @display_name, @display_symbol)
    ON CONFLICT(ca) DO UPDATE SET
      name=COALESCE(excluded.name, token_meta.name),
      symbol=COALESCE(excluded.symbol, token_meta.symbol),
      pump_url=excluded.pump_url,
      dex_url=excluded.dex_url,
      pair_address=COALESCE(excluded.pair_address, token_meta.pair_address),
      on_dex_at_reg=COALESCE(token_meta.on_dex_at_reg, excluded.on_dex_at_reg),
      logo_url=COALESCE(excluded.logo_url, token_meta.logo_url),
      display_name=COALESCE(excluded.display_name, token_meta.display_name),
      display_symbol=COALESCE(excluded.display_symbol, token_meta.display_symbol)
  `).run({
    ca: tokenCA,
    name: fields.name || null,
    symbol: fields.symbol || null,
    pump_url,
    dex_url,
    pair_address: fields.pair_address || null,
    on_dex_at_reg: Number(fields.on_dex_at_reg || 0),
    logo_url: fields.logo_url || null,
    display_name: fields.display_name || null,
    display_symbol: fields.display_symbol || null,
  });

  const result = getMeta(tokenCA);
  metaCache.set(tokenCA, { data: result, timestamp: Date.now() });
  return result;
}

async function refreshMetaPriority(tokenCA) {
  const cached = metaCache.get(tokenCA);
  if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {
    return cached.data;
  }

  const isPump = String(tokenCA).toLowerCase().endsWith('pump');

  let pump = { ok: false }
  let dexPair = null;

  if (isPump) {
    pump = await fetchPumpMeta(tokenCA);
    try { dexPair = await fetchDexPair(tokenCA); } catch {}
  } else {
    try { dexPair = await fetchDexPair(tokenCA); } catch {}
    pump = await fetchPumpMeta(tokenCA);
  }

  const name = (isPump ? (pump.name || null) : (pairName(dexPair) || null)) || pump.name || pairName(dexPair) || null;
  const symbol = (isPump ? (pump.symbol || null) : (pairSymbol(dexPair) || null)) || pump.symbol || pairSymbol(dexPair) || null;

  const logo_url =
    (isPump ? (pump.img || null) : (pairLogo(dexPair) || null)) ||
    pump.img ||
    pairLogo(dexPair) ||
    null;

  const onDexAtReg = dexPair ? 1 : 0;
  const pairAddr = dexPair ? pairAddress(dexPair) : null;

  upsertTokenMeta(tokenCA, { name, symbol, on_dex_at_reg: onDexAtReg, pair_address: pairAddr, logo_url });

  if (dexPair) {
    const mc = pairMarketCap(dexPair);
    if (mc > 0) {
      db.prepare(`UPDATE token_meta SET last_mc=?, last_checked_at=? WHERE ca=?`).run(mc, now(), tokenCA);
    }
  }

  const result = getMeta(tokenCA);
  metaCache.set(tokenCA, { data: result, timestamp: Date.now() });
  return result;
}

/* =========================
   POSTING FUNCTION - UPDATED FORMAT!
========================= */
async function postToChannelAndGroups(tokenCA, extraLine = '') {
  console.log(`ðŸš€ POST for Token: ${tokenCA}`);
  
  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const token = getToken(tokenCA);
  const creatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  const displayName = meta?.display_name || meta?.name || 'Unknown Token';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  const isPump = String(tokenCA).toLowerCase().endsWith('pump');
  
  // Format: "Token Name (Symbol) - Pump #Symbol"
  const tokenLine = `${displayName} (${displaySymbol}) - Pump #${displaySymbol}`;
  
  const caption = `ðŸŽ­ WHITEMEME ðŸš€ NEW TOKEN LISTED!

ðŸª™ Token: ${tokenLine}
ðŸ’Ž Market Cap: ${formatMc(Number(meta?.last_mc || 0))}
ðŸ† Creator Pool: ${fmtSol(creatorPool)} SOL

ðŸ” CA: ${monospace(tokenCA)}

${extraLine || 'âœ… Activated (deposit confirmed) ðŸŽ‰'}

âœ… Registered holders can earn rewards!
â° Minimum hold: ${MIN_HOLD_HOURS} hours
ðŸš€ Longer hold = More rewards!`;

  try {
    const me = await bot.telegram.getMe();
    
    let buttons;
    if (isPump) {
      buttons = Markup.inlineKeyboard([
        [
          Markup.button.url('ðŸš€ Pump.fun', meta?.pump_url || pumpfunLink(tokenCA)),
          Markup.button.url('ðŸ“Š Chart', meta?.dex_url || dexscreenerTokenLink(tokenCA)),
        ],
        [Markup.button.url('ðŸ¤– Open WhiteMeme Bot', `https://t.me/${me.username}`)],
      ]);
    } else {
      buttons = Markup.inlineKeyboard([
        [
          Markup.button.url('ðŸ“Š Chart', meta?.dex_url || dexscreenerTokenLink(tokenCA)),
        ],
        [Markup.button.url('ðŸ¤– Open WhiteMeme Bot', `https://t.me/${me.username}`)],
      ]);
    }

    const img = meta?.logo_url || null;

    if (img) {
      broadcastToChannelAndGroups('sendPhoto', [img, { 
        caption, 
        reply_markup: buttons.reply_markup,
        parse_mode: 'Markdown'
      }], `(listing ${tokenCA.slice(0, 6)}...)`);
    } else {
      broadcastToChannelAndGroups('sendMessage', [caption, { 
        reply_markup: buttons.reply_markup,
        parse_mode: 'Markdown'
      }], `(listing ${tokenCA.slice(0, 6)}...)`);
    }

    console.log(`âœ… Listing post queued for Token: ${tokenCA}`);

  } catch (error) {
    console.log(`âŒ Error creating listing post: ${error.message}`);
  }
}

/* =========================
   AUTO-PAYOUT SCHEDULER (20:00 UTC Daily)
========================= */
function startAutoPayoutScheduler() {
  console.log('â° Starting Auto-Payout Scheduler (20:00 UTC daily)...');
  
  const scheduleNextPayout = () => {
    const now = new Date();
    const target = new Date(now);
    target.setUTCHours(20, 0, 0, 0);
    
    if (now > target) {
      target.setUTCDate(target.getUTCDate() + 1);
    }
    
    const delay = target.getTime() - now.getTime();
    
    console.log(`â° Next auto-payout scheduled for: ${target.toUTCString()} (in ${Math.round(delay / 1000 / 60)} minutes)`);
    
    setTimeout(async () => {
      console.log('ðŸ’° Starting automatic daily payout...');
      try {
        const result = await manualPayoutAllTokens();
        console.log(`âœ… Auto-payout completed: ${result.message}`);
        
        const adminMsg = `ðŸ’° Daily Auto-Payout Executed\n\nStatus: ${result.success ? 'âœ… SUCCESS' : 'âš ï¸ PARTIAL'}\nMessage: ${result.message}\nTime: ${new Date().toLocaleString()}`;
        for (const adminId of ADMIN_IDS) {
          try {
            await bot.telegram.sendMessage(adminId, adminMsg);
          } catch {}
        }
      } catch (error) {
        console.log('âŒ Auto-payout failed:', error.message);
      }
      
      scheduleNextPayout();
    }, delay);
  };
  
  scheduleNextPayout();
}

/* =========================
   FEES + DEPOSIT CHECK
========================= */
async function sendFeeTransfer(feeSol) {
  return await withRetry(async () => {
    const lamports = Math.floor(feeSol * LAMPORTS_PER_SOL);
    if (lamports <= 0) return null;

    const sendLamports = Math.max(0, lamports - 10_000);
    if (sendLamports <= 0) return null;

    const to = new PublicKey(FEE_WALLET);
    const tx = new Transaction().add(
      SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: to, lamports: sendLamports })
    );

    const sig = await sendAndConfirmTransaction(connection, tx, [payer], { commitment: 'confirmed' });
    return sig;
  }, 'sendFeeTransfer');
}

async function verifyDepositTx(signature, expectedToWallet) {
  return await withRetry(async () => {
    const parsed = await connection.getParsedTransaction(signature, {
      commitment: 'confirmed',
      maxSupportedTransactionVersion: 0,
    });

    if (!parsed?.meta) return { ok: false, reason: 'tx_not_found' };

    let found = false;
    let fromWallet = null;
    let solAmount = 0;

    const instructions = parsed.transaction.message.instructions || [];
    for (const ix of instructions) {
      if (ix?.program === 'system') {
        const info = ix?.parsed?.info;
        if (info?.destination === expectedToWallet && info?.lamports) {
          found = true;
          fromWallet = info?.source || null;
          solAmount += Number(info.lamports) / LAMPORTS_PER_SOL;
        }
      }
    }

    if (!found) return { ok: false, reason: 'no_transfer_to_reward_wallet' };
    if (solAmount <= 0) return { ok: false, reason: 'zero_amount' };
    return { ok: true, solAmount, fromWallet };
  }, 'verifyDepositTx');
}

/* =========================
   STATE
========================= */
const state = new Map();
const setState = (uid, obj) => state.set(uid, obj);
const getState = (uid) => state.get(uid);
const clearState = (uid) => state.delete(uid);

/* =========================
   CALLBACK KEYS
========================= */
const CB = {
  HOME: 'H',
  HELP: 'HP',
  CRE_HOME: 'CH',
  HOL_HOME: 'HH',
  CRE_REG: 'CR',
  CRE_LIST: 'CL',
  HOL_REG: 'HR',
  HOL_MY: 'HM',
  HOL_REM: 'HD',
  ADM_HOME: 'AH',
  ADM_SUM: 'AS',
  ADM_PAYOUT: 'AP',
  ADM_GROUPS: 'AG',
  ADM_TOKENS: 'AT',
};

function paginateRows(rows, page, pageSize) {
  const p = Math.max(0, Number(page || 0));
  const start = p * pageSize;
  const slice = rows.slice(start, start + pageSize);
  const maxPage = Math.max(0, Math.ceil(rows.length / pageSize) - 1);
  return { page: p, maxPage, slice };
}

/* =========================
   MENUS
========================= */
function homeKeyboard(ctx) {
  const rows = [
    [Markup.button.callback('ðŸ‘¨â€ðŸŽ¨ Creator Panel', CB.CRE_HOME)],
    [Markup.button.callback('ðŸ‘¥ Holder Panel', CB.HOL_HOME)],
    [
      ...(CHANNEL_LINK ? [Markup.button.url('ðŸ“¢ Channel', CHANNEL_LINK)] : []),
      ...(TWITTER_LINK ? [Markup.button.url('ð• Twitter', TWITTER_LINK)] : []),
    ].filter(Boolean),
    [Markup.button.callback('â“ Help', CB.HELP)],
  ];

  if (isAdmin(ctx)) rows.push([Markup.button.callback('âš¡ Admin Panel', CB.ADM_HOME)]);

  return Markup.inlineKeyboard(rows.filter(r => r.length));
}

function creatorHomeKeyboard() {
  return Markup.inlineKeyboard([
    [Markup.button.callback('âž• Register Token', CB.CRE_REG)],
    [Markup.button.callback('ðŸ—‚ï¸ My Tokens', `${CB.CRE_LIST}:0`)],
    [Markup.button.callback('ðŸ  Start', CB.HOME)],
  ]);
}

function holderHomeKeyboard() {
  return Markup.inlineKeyboard([
    [Markup.button.callback('âœ… Register as Holder', CB.HOL_REG)],
    [Markup.button.callback('ðŸ“‹ My Registrations', `${CB.HOL_MY}:0`)],
    [Markup.button.callback('ðŸ—‘ï¸ Remove Registration', CB.HOL_REM)],
    [Markup.button.callback('ðŸ  Start', CB.HOME)],
  ]);
}

function adminHomeKeyboard() {
  return Markup.inlineKeyboard([
    [Markup.button.callback('ðŸ“ˆ Global Analytics', CB.ADM_SUM)],
    [Markup.button.callback('ðŸš€ RUN PAYOUT NOW', CB.ADM_PAYOUT)],
    [Markup.button.callback('ðŸª™ Manage Tokens', `${CB.ADM_TOKENS}:0`)],
    [Markup.button.callback('ðŸ‘¥ Manage Groups', `${CB.ADM_GROUPS}:0`)],
    [Markup.button.callback('ðŸ  Start', CB.HOME)],
  ]);
}

function tokenConfirmKeyboard(tokenCA) {
  return Markup.inlineKeyboard([
    [Markup.button.callback('âœ… Confirm Token', `CONF:${tokenCA}`)],
    [Markup.button.callback('âŒ Cancel', 'CXL')],
  ]);
}

function creatorManageKeyboard(tokenCA) {
  const buttons = [
    [Markup.button.callback('ðŸ’¸ Deposit / Check Payment', `DEP:${tokenCA}`)],
    [
      Markup.button.callback('ðŸ“Š Stats', `CST:${tokenCA}`),
      Markup.button.callback('ðŸ“‹ Report', `REP:${tokenCA}`),
    ],
    [
      Markup.button.callback('ðŸ‘¤ Holder Stats', `CHS:${tokenCA}`),
      Markup.button.callback('ðŸŽ¨ Edit Display', `EDN:${tokenCA}`),
    ],
    [Markup.button.callback('ðŸš« Deactivate', `DEA:${tokenCA}`)],
    [Markup.button.callback('â¬…ï¸ Back', `${CB.CRE_LIST}:0`)],
  ];
  
  return Markup.inlineKeyboard(buttons);
}

function paymentKeyboard(tokenCA) {
  return Markup.inlineKeyboard([
    [Markup.button.callback('ðŸ”Ž Check Payment', `CHK:${tokenCA}`)],
    [Markup.button.callback('â¬…ï¸ Back', `MAN:${tokenCA}`)],
  ]);
}

function adminTokenActionsKeyboard(tokenCA, backPage = 0) {
  return Markup.inlineKeyboard([
    [
      Markup.button.callback('ðŸ”„ Repost', `AR:${tokenCA}:${backPage}`),
      Markup.button.callback('ðŸ’¸ PAY NOW', `PAYTOKEN:${tokenCA}`),
    ],
    [
      Markup.button.callback('ðŸŽ—ï¸ Bonded Posts', `BONDED:${tokenCA}:${backPage}`),
      Markup.button.callback('ðŸ§® Calc Payout', `CALCPAY:${tokenCA}:${backPage}`),
    ],
    [
      Markup.button.callback('ðŸ†‘ Reset Alerts', `AX:${tokenCA}:${backPage}`),
      Markup.button.callback('ðŸ“ˆ Update MC', `UPDATEMC:${tokenCA}:${backPage}`),
    ],
    [
      Markup.button.callback('âœ… Activate', `AA:${tokenCA}:${backPage}`),
      Markup.button.callback('â­• Inactivate', `AI:${tokenCA}:${backPage}`),
    ],
    [Markup.button.callback('ðŸ—‘ï¸ Delete', `AD:${tokenCA}:${backPage}`)],
    [Markup.button.callback('â¬…ï¸ Back', `${CB.ADM_TOKENS}:${backPage}`)],
  ]);
}

/* =========================
   GROUP ACTIVATION
========================= */
function saveGroupChat(ctx) {
  if (ctx.chat?.type !== 'group' && ctx.chat?.type !== 'supergroup') return false;
  db.prepare(`
    INSERT INTO groups (chat_id, title, active, created_at, last_error)
    VALUES (?, ?, 1, ?, NULL)
    ON CONFLICT(chat_id) DO UPDATE SET active=1, title=excluded.title, last_error=NULL
  `).run(String(ctx.chat.id), ctx.chat.title || '', now());
  return true;
}

bot.command('activate', async (ctx) => {
  const ok = saveGroupChat(ctx);
  if (!ok) return ctx.reply('âš ï¸ Use /activate inside a group.');
  await ctx.reply('âœ… Group activated! This group will now receive ðŸŽ­ WHITEMEME posts. ðŸš€');
  cleanupAfterDelay(ctx, 3000);
});

bot.command('syncgroup', async (ctx) => {
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');
  const ok = saveGroupChat(ctx);
  if (!ok) return ctx.reply('âš ï¸ Use /syncgroup inside a group.');
  await ctx.reply('âœ… Group synced and activated (admin).');
  cleanupAfterDelay(ctx, 3000);
});

bot.command('testbroadcast', async (ctx) => {
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');
  const groups = getActiveGroups();
  const msg = `ðŸ“¢ ðŸŽ­ WHITEMEME TEST BROADCAST\n\nIf you see this in the channel AND your groups, delivery is working âœ…\nChannel target: ${CHANNEL_ID}\nActive groups: ${groups.length}\n\nTime: ${new Date().toUTCString()} ðŸš€`;
  broadcastToChannelAndGroups('sendMessage', [msg], '(testbroadcast)');
  await ctx.reply('âœ… Test broadcast queued. Check your channel and group(s).');
  cleanupAfterDelay(ctx, 3000);
});

/* =========================
   ADMIN CONTROLS FOR BONDED POSTING
========================= */
bot.action(/^BONDED:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  const confirmKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback('âœ… 2X Post', `BONDEDFORCE:${tokenCA}:2:${backPage}`)],
    [Markup.button.callback('âœ… 5X Post', `BONDEDFORCE:${tokenCA}:5:${backPage}`)],
    [Markup.button.callback('âœ… 10X Post', `BONDEDFORCE:${tokenCA}:10:${backPage}`)],
    [Markup.button.callback('ðŸ”„ Reset Milestones', `BONDEDRESET:${tokenCA}:${backPage}`)],
    [Markup.button.callback('ðŸ”™ Back', `${CB.ADM_TOKENS}:${backPage}`)],
  ]);
  
  const meta = getMeta(tokenCA);
  const baseMC = Number(meta?.base_mc || 0);
  const currentMC = Number(meta?.last_mc || 0);
  const bondedPosted = Number(meta?.bonded_posted || 0);
  
  let status = 'No base MC set';
  if (baseMC > 0 && currentMC > 0) {
    const multiplier = (currentMC / baseMC).toFixed(2);
    status = `${multiplier}x from base (${formatMc(currentMC)} / ${formatMc(baseMC)})`;
  }
  
  await ctx.reply(
`ðŸŽ—ï¸ Bonded Posting Control

Token: ${meta?.display_name || meta?.name || 'Unknown'}
Current: ${status}
Last posted milestone: ${bondedPosted > 0 ? `${bondedPosted}x` : 'None'}

Force post a milestone or reset:`,
    confirmKeyboard
  );
});

bot.action(/^BONDEDFORCE:(.+):(\d+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');
  
  const tokenCA = ctx.match[1];
  const milestone = Number(ctx.match[2]);
  const backPage = Number(ctx.match[3] || 0);
  
  const isPump = String(tokenCA).toLowerCase().endsWith('pump');
  const meta = getMeta(tokenCA);
  const isBonded = meta?.on_dex_at_reg === 1 && isPump;
  
  db.prepare(`UPDATE token_meta SET bonded_posted=? WHERE ca=?`).run(milestone, tokenCA);
  
  await postMilestone(tokenCA, milestone, isBonded);
  
  await ctx.reply(`âœ… Forced ${milestone}x ${isBonded ? 'bonded' : 'milestone'} post for token.`, adminHomeKeyboard());
});

bot.action(/^BONDEDRESET:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  db.prepare(`UPDATE token_meta SET bonded_posted=0, last_x_posted=0 WHERE ca=?`).run(tokenCA);
  
  await ctx.reply(`âœ… Bonded milestones reset for token.`, adminHomeKeyboard());
});

bot.action(/^UPDATEMC:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  try {
    const pair = await fetchDexPair(tokenCA);
    if (pair) {
      const mc = pairMarketCap(pair);
      const meta = getMeta(tokenCA);
      
      if (mc > 0) {
        db.prepare(`UPDATE token_meta SET last_mc=?, last_checked_at=? WHERE ca=?`)
          .run(mc, now(), tokenCA);
        
        if (!meta?.base_mc || Number(meta.base_mc) <= 0) {
          db.prepare(`UPDATE token_meta SET base_mc=? WHERE ca=?`).run(mc, tokenCA);
        }
        
        await ctx.reply(`âœ… Market Cap updated: ${formatMc(mc)}`, adminHomeKeyboard());
      } else {
        await ctx.reply(`âš ï¸ No market cap found`, adminHomeKeyboard());
      }
    } else {
      await ctx.reply(`âš ï¸ No pair data found`, adminHomeKeyboard());
    }
  } catch (error) {
    await ctx.reply(`âŒ Error: ${error.message}`, adminHomeKeyboard());
  }
});

/* =========================
   START / HOME / HELP
========================= */
async function sendWelcome(ctx) {
  clearState(ctx.from.id);
  
  await cleanupPreviousMessage(ctx);

  if (ctx.chat?.type === 'group' || ctx.chat?.type === 'supergroup') {
    saveGroupChat(ctx);
    return ctx.reply('âœ… Group activated! This group will receive ðŸŽ­ WHITEMEME posts. ðŸš€');
  }

  const text = `ðŸŽ­ WELCOME TO WHITEMEME BOT ðŸ¤–

âœ¨ What you can do here:

ðŸ‘¨â€ðŸŽ¨ Creators
1) Register your token (any Solana mint CA) ðŸª™
2) Confirm the token âœ…
3) Fund the rewards pool (send SOL) ðŸ’°
4) After your deposit is confirmed, the bot posts to the Channel + Active Groups âœ…

ðŸ‘¥ Holders
1) Register for a token ðŸ“
2) Add your Solana wallet ðŸ‘›
3) Stay eligible by holding long enough â°

ðŸ”’ Safety
ðŸ‘› No custody. No private keys. You control your wallet.

Tap a panel below to start ðŸ‘‡`;

  await ctx.reply(text, homeKeyboard(ctx));
}

bot.start(async (ctx) => {
  await cleanupPreviousMessage(ctx);
  await sendWelcome(ctx);
});

bot.action(CB.HOME, async (ctx) => { 
  await safeAnswerCb(ctx); 
  await sendWelcome(ctx); 
});

bot.action(CB.HELP, async (ctx) => {
  await safeAnswerCb(ctx);

  let text = `â“ HELP & GUIDELINES ðŸ“š

ðŸ‘¨â€ðŸŽ¨ CREATOR FLOW
1) Creator Panel â†’ Register Token (paste mint CA) ðŸª™
2) Confirm token âœ…
3) Deposit/Payment â†’ Send SOL to the Reward Wallet ðŸ’¸
4) Paste Solscan TX link â†’ Check Payment ðŸ”Ž
5) After confirmed: bot posts to the Channel + Active Groups ðŸš€

ðŸ‘¥ HOLDER FLOW
1) Holder Panel â†’ Register as Holder ðŸ“
2) Send Token CA ðŸª™
3) Send your Solana wallet ðŸ‘›

âœ… Eligibility rules
- Minimum hold time: ${MIN_HOLD_HOURS} hours â°
- Minimum holding: ${(MIN_HOLDER_PCT * 100).toFixed(4)}% of total supply ðŸª™
- Do NOT sell during holding period ðŸ“‰
- The longer you hold, the more rewards you earn! ðŸ’Ž

ðŸ‘¥ GROUPS
- In a group: /activate (anyone) or /syncgroup (admin) ðŸ”§

ðŸŽ—ï¸ BONDED POSTING
- Auto-posts at 2x, 5x, 10x market cap milestones ðŸ“ˆðŸš€ðŸ’Ž
- Uses ðŸŽ—ï¸ emoji for bonded posts (Pump.fun tokens only)

ðŸ’¡ Tip: You will receive DM notifications for payouts! ðŸ“¨`;

  if (isAdmin(ctx)) {
    text += `

âš¡ ADMIN SECTION (Your ID: ${ctx.from.id})
- Analytics, manage tokens/groups, repost, reset alerts, run payouts.
- Use /testbroadcast to verify delivery instantly.`;
  }

  await ctx.reply(text);
});

/* =========================
   HOLDER PANEL
========================= */
bot.action(CB.HOL_HOME, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  await safeEditOrReply(ctx, 'ðŸ‘¥ Holder Panel', holderHomeKeyboard());
});

bot.action(CB.HOL_REG, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  setState(ctx.from.id, { mode: 'holder_send_token' });
  await ctx.reply(
`âœ… Holder Registration ðŸ“

To register for rewards:
1. Send token CA (mint address) ðŸª™
2. Send your Solana wallet address ðŸ‘›

You must:
â€¢ Hold at least ${(MIN_HOLDER_PCT * 100).toFixed(4)}% of token supply ðŸª™
â€¢ Hold for minimum ${MIN_HOLD_HOURS} hours â°
â€¢ Do NOT sell during holding period ðŸ“‰

Send the token CA now:`
  );
});

bot.action(CB.HOL_REM, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  setState(ctx.from.id, { mode: 'holder_remove_token' });
  await ctx.reply(
`ðŸ—‘ï¸ Remove Registration

Send the token CA you want to remove registration for:`,
    holderHomeKeyboard()
  );
});

async function renderHolderRegistrations(ctx, page = 0) {
  const uid = ctx.from.id;
  const rows = db.prepare(`
    SELECT h.ca, h.wallet, h.registered_at, h.total_paid,
           COALESCE(tm.display_name, tm.name) as name,
           COALESCE(tm.display_symbol, tm.symbol) as symbol
    FROM holders h
    LEFT JOIN token_meta tm ON tm.ca=h.ca
    WHERE h.tg_id=?
    ORDER BY h.registered_at DESC
  `).all(uid);

  if (!rows.length) {
    return safeEditOrReply(ctx, 'ðŸ“‹ No registrations yet.\n\nRegister for a token to start earning rewards! ðŸš€', holderHomeKeyboard());
  }

  const { page: p, maxPage, slice } = paginateRows(rows, page, 5);

  let msg = `ðŸ“‹ My Registrations (${p + 1}/${maxPage + 1})\n\n`;
  slice.forEach((r, idx) => {
    const name = r.name || 'Unknown';
    const symbol = r.symbol ? `$${r.symbol}` : 'N/A';
    const walletShort = r.wallet.slice(0, 8) + '...' + r.wallet.slice(-4);
    const registered = new Date(r.registered_at).toLocaleDateString();
    const holdHours = ((now() - r.registered_at) / (1000 * 60 * 60)).toFixed(1);
    const totalPaid = Number(r.total_paid || 0);
    
    msg += `${idx+1}. ${name} (${symbol})\n`;
    msg += `   Wallet: ${walletShort}\n`;
    msg += `   Registered: ${registered}\n`;
    msg += `   Hold time: ${holdHours}h / ${MIN_HOLD_HOURS}h â°\n`;
    msg += `   Total earned: ${fmtSol(totalPaid)} SOL ðŸ’°\n\n`;
  });

  const nav = [];
  if (p > 0) nav.push(Markup.button.callback('â—€ï¸ Back', `${CB.HOL_MY}:${p - 1}`));
  if (p < maxPage) nav.push(Markup.button.callback('Next â–¶ï¸', `${CB.HOL_MY}:${p + 1}`));

  const kb = Markup.inlineKeyboard([
    ...(nav.length ? [nav] : []),
    [Markup.button.callback('âœ… New Registration', CB.HOL_REG)],
    [Markup.button.callback('ðŸ—‘ï¸ Remove Registration', CB.HOL_REM)],
    [Markup.button.callback('ðŸ  Start', CB.HOME)],
  ]);

  await safeEditOrReply(ctx, msg, kb, 0);
}

bot.action(new RegExp(`^${CB.HOL_MY}:(\\d+)$`), async (ctx) => {
  await safeAnswerCb(ctx);
  await renderHolderRegistrations(ctx, Number(ctx.match[1] || 0));
});

/* =========================
   ADMIN PANEL - COMPLETELY FIXED!
========================= */
bot.action(CB.ADM_HOME, async (ctx) => {
  console.log('âš¡ Admin Panel clicked, user ID:', ctx.from.id);
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  await safeEditOrReply(ctx, 'âš¡ Admin Panel', adminHomeKeyboard());
});

bot.action(CB.ADM_SUM, async (ctx) => {
  await safeAnswerCb(ctx);
  await showAdminSummary(ctx);
});

bot.action(CB.ADM_PAYOUT, async (ctx) => {
  await safeAnswerCb(ctx);
  await executeAdminPayout(ctx);
});

// Neue Navigation Handler fÃ¼r Admin Tokens
bot.action(/^ADM_TOKENS_PREV:(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  await renderAdminTokens(ctx, Number(ctx.match[1] || 0));
});

bot.action(/^ADM_TOKENS_NEXT:(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  await renderAdminTokens(ctx, Number(ctx.match[1] || 0));
});

bot.action(new RegExp(`^${CB.ADM_TOKENS}:(\\d+)$`), async (ctx) => {
  console.log('ðŸ” ADM_TOKENS callback received:', ctx.callbackQuery.data);
  await safeAnswerCb(ctx);
  await renderAdminTokens(ctx, Number(ctx.match[1] || 0));
});

bot.action(new RegExp(`^${CB.ADM_GROUPS}:(\\d+)$`), async (ctx) => {
  await safeAnswerCb(ctx);
  await renderAdminGroups(ctx, Number(ctx.match[1] || 0));
});

async function showAdminSummary(ctx) {
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');

  const tokenStats = db.prepare(`
    SELECT 
      COUNT(*) as total,
      SUM(CASE WHEN status='ACTIVE' THEN 1 ELSE 0 END) as active,
      SUM(CASE WHEN status='PENDING_PAYMENT' THEN 1 ELSE 0 END) as pending,
      SUM(CASE WHEN status='PENDING_CONFIRM' THEN 1 ELSE 0 END) as unconfirmed
    FROM tokens
  `).get();

  const depositStats = db.prepare(`
    SELECT 
      COALESCE(SUM(sol_amount), 0) as total_deposited,
      COALESCE(SUM(fee_sol), 0) as total_fees,
      COALESCE(SUM(reward_sol), 0) as total_rewards,
      COUNT(*) as total_transactions
    FROM deposits
  `).get();

  const payoutStats = db.prepare(`
    SELECT 
      COALESCE(SUM(sol_amount), 0) as total_paid,
      COUNT(DISTINCT ca) as tokens_paid,
      COUNT(*) as total_payouts
    FROM payouts
  `).get();

  const holderStats = db.prepare(`
    SELECT 
      COUNT(*) as total_holders,
      COUNT(DISTINCT ca) as tokens_with_holders,
      COALESCE(SUM(total_paid), 0) as total_rewards_paid
    FROM holders
  `).get();

  const groupStats = db.prepare(`
    SELECT 
      COUNT(*) as total_groups,
      SUM(CASE WHEN active=1 THEN 1 ELSE 0 END) as active_groups
    FROM groups
  `).get();

  // Neue Statistik: Creator Pools
  const creatorPoolStats = db.prepare(`
    SELECT 
      COUNT(DISTINCT creator_tg_id) as unique_creators,
      COUNT(*) as creator_pools,
      COALESCE(SUM(sol_amount), 0) as total_creator_pools
    FROM creator_token_pools
  `).get();

  const msg = `ðŸ“Š ADMIN SUMMARY

ðŸª™ TOKENS
Total: ${tokenStats.total}
Active: ${tokenStats.active}
Pending Payment: ${tokenStats.pending}
Unconfirmed: ${tokenStats.unconfirmed}

ðŸ’° FINANCIAL
Total Deposited: ${fmtSol(depositStats.total_deposited)} SOL
Total Fees: ${fmtSol(depositStats.total_fees)} SOL
Total Rewards Pool: ${fmtSol(depositStats.total_rewards)} SOL
Total Paid Out: ${fmtSol(payoutStats.total_paid)} SOL
Total Rewards Paid: ${fmtSol(holderStats.total_rewards_paid)} SOL

ðŸ‘¨â€ðŸŽ¨ CREATOR POOLS (NEU)
Unique Creators: ${creatorPoolStats.unique_creators}
Creator Pools: ${creatorPoolStats.creator_pools}
Total Creator Pools: ${fmtSol(creatorPoolStats.total_creator_pools)} SOL

ðŸ‘¥ HOLDERS
Total Holders: ${holderStats.total_holders}
Tokens with Holders: ${holderStats.tokens_with_holders}

ðŸ“¢ GROUPS
Total Groups: ${groupStats.total_groups}
Active Groups: ${groupStats.active_groups}`;

  await ctx.reply(msg, adminHomeKeyboard());
}

async function executeAdminPayout(ctx) {
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');

  await ctx.reply('ðŸš€ Starting manual payout for all active tokens...');

  try {
    const result = await manualPayoutAllTokens();
    
    let msg = `ðŸ’° MANUAL PAYOUT COMPLETE\n\n`;
    msg += `Status: ${result.success ? 'âœ… SUCCESS' : 'âš ï¸ PARTIAL'}\n`;
    msg += `Message: ${result.message}\n`;
    msg += `Total Paid: ${fmtSol(result.totalPaid || 0)} SOL\n`;
    msg += `Recipients: ${result.totalRecipients || 0}\n`;
    msg += `Tokens Processed: ${result.results?.length || 0}\n\n`;
    
    if (result.results?.length > 0) {
      msg += `Token Results:\n`;
      result.results.forEach((r, idx) => {
        msg += `${idx+1}. ${r.tokenName || r.tokenCA.slice(0, 8)} (Creator ${r.creatorId}): ${fmtSol(r.paid || 0)} SOL to ${r.recipients || 0} holders\n`;
      });
    }
    
    await ctx.reply(msg, adminHomeKeyboard());
  } catch (error) {
    await ctx.reply(`âŒ Payout failed: ${error.message}`, adminHomeKeyboard());
  }
}

async function renderAdminTokens(ctx, page = 0) {
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');

  const rows = db.prepare(`
    SELECT t.ca, t.status, t.created_at, t.creator_tg_id, t.creator_username,
           COALESCE(tm.display_name, tm.name) as name,
           COALESCE(tm.display_symbol, tm.symbol) as symbol,
           (SELECT COALESCE(SUM(reward_sol),0) FROM deposits d WHERE d.ca=t.ca) as total_pool,
           (SELECT COALESCE(sol_amount,0) FROM creator_token_pools WHERE creator_tg_id=t.creator_tg_id AND token_ca=t.ca) as creator_pool,
           (SELECT COUNT(*) FROM holders h WHERE h.ca=t.ca) as holder_count
    FROM tokens t
    LEFT JOIN token_meta tm ON tm.ca=t.ca
    ORDER BY t.created_at DESC
  `).all();

  console.log(`ðŸ“Š Found ${rows.length} tokens in database`);

  if (!rows.length) {
    return ctx.reply('ðŸª™ No tokens in database.', adminHomeKeyboard());
  }

  const pageSize = 5;
  const currentPage = Math.max(0, Number(page || 0));
  const startIdx = currentPage * pageSize;
  const endIdx = startIdx + pageSize;
  const slice = rows.slice(startIdx, endIdx);
  const maxPage = Math.max(0, Math.ceil(rows.length / pageSize) - 1);

  let msg = `ðŸª™ Admin Token Management (${currentPage + 1}/${maxPage + 1})\n\n`;
  
  slice.forEach((r, idx) => {
    const name = r.name || 'Unknown';
    const symbol = r.symbol ? `$${r.symbol}` : 'N/A';
    const totalPool = Number(r.total_pool || 0);
    const creatorPool = Number(r.creator_pool || 0);
    const date = new Date(r.created_at).toLocaleDateString();
    
    msg += `${startIdx + idx + 1}. ${name} (${symbol})\n`;
    msg += `   Status: ${r.status}\n`;
    msg += `   Creator: ${r.creator_username || r.creator_tg_id}\n`;
    msg += `   Total Pool: ${fmtSol(totalPool)} SOL\n`;
    msg += `   Creator Pool: ${fmtSol(creatorPool)} SOL ðŸŽ¯\n`;
    msg += `   Holders: ${r.holder_count}\n`;
    msg += `   Created: ${date}\n`;
    msg += `   CA: ${monospace(r.ca.slice(0, 12) + '...')}\n\n`;
  });

  // Navigation buttons with unique callback data
  const nav = [];
  if (currentPage > 0) {
    nav.push(Markup.button.callback('â—€ï¸ Back', `ADM_TOKENS_PREV:${currentPage - 1}`));
  }
  if (currentPage < maxPage) {
    nav.push(Markup.button.callback('Next â–¶ï¸', `ADM_TOKENS_NEXT:${currentPage + 1}`));
  }

  // Create token selection buttons with UNIQUE callback data
  const tokenButtons = slice.map((r, idx) => [
    Markup.button.callback(`Token ${startIdx + idx + 1}`, `ADMIN_TOKEN_SELECT:${r.ca}:${currentPage}:${idx}`)
  ]);

  const keyboardRows = [
    ...tokenButtons,
    ...(nav.length > 0 ? [nav] : []),
    [Markup.button.callback('ðŸ  Home', CB.HOME)],
  ];

  const kb = Markup.inlineKeyboard(keyboardRows);

  try {
    // If it's a callback query, edit the message
    if (ctx.callbackQuery) {
      await ctx.editMessageText(msg, {
        reply_markup: kb.reply_markup,
        parse_mode: 'Markdown'
      });
    } else {
      // If it's a regular message, reply
      await ctx.reply(msg, {
        reply_markup: kb.reply_markup,
        parse_mode: 'Markdown'
      });
    }
  } catch (error) {
    console.log('âŒ Error rendering admin tokens:', error.message);
    // Fallback: send new message
    await ctx.reply(msg, {
      reply_markup: kb.reply_markup,
      parse_mode: 'Markdown'
    });
  }
}

// Aktualisierter Token Select Handler mit unique callback
bot.action(/^ADMIN_TOKEN_SELECT:(.+):(\d+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  const token = getToken(tokenCA);
  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const creatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  const totalFunded = getTotalFunded(tokenCA);
  const holderCount = countHoldersForToken(tokenCA);
  
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  const msg = `ðŸª™ ADMIN TOKEN DETAILS

Name: ${displayName}
Symbol: ${displaySymbol ? `$${displaySymbol}` : 'N/A'}
CA: ${monospace(tokenCA)}

Status: ${token?.status || 'UNKNOWN'}
Creator: ${token?.creator_username || token?.creator_tg_id}
Created: ${new Date(token?.created_at || 0).toLocaleString()}

Market Cap: ${formatMc(Number(meta?.last_mc || 0))} ðŸ’Ž
CREATOR POOL: ${fmtSol(creatorPool)} SOL ðŸŽ¯
Total Funded: ${fmtSol(totalFunded)} SOL
Registered Holders: ${holderCount} ðŸ‘¥

Pump.fun: ${meta?.pump_url || 'N/A'}
DexScreener: ${meta?.dex_url || 'N/A'}

Choose action:`;
  
  await ctx.reply(msg, adminTokenActionsKeyboard(tokenCA, backPage));
});

// Behalte den alten Handler fÃ¼r KompatibilitÃ¤t
bot.action(/^ADMIN_TOKEN:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  const token = getToken(tokenCA);
  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const creatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  const totalFunded = getTotalFunded(tokenCA);
  const holderCount = countHoldersForToken(tokenCA);
  
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  const msg = `ðŸª™ ADMIN TOKEN DETAILS

Name: ${displayName}
Symbol: ${displaySymbol ? `$${displaySymbol}` : 'N/A'}
CA: ${monospace(tokenCA)}

Status: ${token?.status || 'UNKNOWN'}
Creator: ${token?.creator_username || token?.creator_tg_id}
Created: ${new Date(token?.created_at || 0).toLocaleString()}

Market Cap: ${formatMc(Number(meta?.last_mc || 0))} ðŸ’Ž
CREATOR POOL: ${fmtSol(creatorPool)} SOL ðŸŽ¯
Total Funded: ${fmtSol(totalFunded)} SOL
Registered Holders: ${holderCount} ðŸ‘¥

Pump.fun: ${meta?.pump_url || 'N/A'}
DexScreener: ${meta?.dex_url || 'N/A'}

Choose action:`;
  
  await ctx.reply(msg, adminTokenActionsKeyboard(tokenCA, backPage));
});

async function renderAdminGroups(ctx, page = 0) {
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');

  const rows = db.prepare(`
    SELECT chat_id, title, active, created_at, last_error
    FROM groups
    ORDER BY created_at DESC
  `).all();

  if (!rows.length) {
    return safeEditOrReply(ctx, 'ðŸ‘¥ No groups in database.', adminHomeKeyboard());
  }

  const { page: p, maxPage, slice } = paginateRows(rows, page, 5);

  let msg = `ðŸ‘¥ Admin Group Management (${p + 1}/${maxPage + 1})\n\n`;
  slice.forEach((r, idx) => {
    const title = r.title || 'No Title';
    const status = r.active ? 'âœ… ACTIVE' : 'âŒ INACTIVE';
    const date = new Date(r.created_at).toLocaleDateString();
    const error = r.last_error ? `\n   Error: ${r.last_error.slice(0, 50)}...` : '';
    
    msg += `${idx+1}. ${title}\n`;
    msg += `   Chat ID: ${r.chat_id}\n`;
    msg += `   Status: ${status}\n`;
    msg += `   Created: ${date}${error}\n\n`;
  });

  const nav = [];
  if (p > 0) nav.push(Markup.button.callback('â—€ï¸ Back', `${CB.ADM_GROUPS}:${p - 1}`));
  if (p < maxPage) nav.push(Markup.button.callback('Next â–¶ï¸', `${CB.ADM_GROUPS}:${p + 1}`));

  const kb = Markup.inlineKeyboard([
    ...(nav.length ? [nav] : []),
    [Markup.button.callback('ðŸ”„ Sync All Groups', 'ADMIN_SYNC_GROUPS')],
    [Markup.button.callback('ðŸ  Home', CB.HOME)],
  ]);

  await safeEditOrReply(ctx, msg, kb, 0);
}

bot.action('ADMIN_SYNC_GROUPS', async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('â›” No access.');
  
  await ctx.reply('ðŸ”„ Syncing all groups... This may take a moment.');
  await ctx.reply('âœ… Group sync function would resync all groups here.', adminHomeKeyboard());
});

bot.action(/^AR:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  await postToChannelAndGroups(tokenCA, 'ðŸ”„ Reposted by admin');
  await ctx.reply('âœ… Token reposted!', adminTokenActionsKeyboard(tokenCA, backPage));
});

bot.action(/^PAYTOKEN:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  
  await ctx.reply(`ðŸ’° Processing payouts for token ${tokenCA.slice(0, 8)}...`);
  
  try {
    const result = await executePayoutsForToken(tokenCA);
    
    let msg = `ðŸ’° PAYOUT RESULTS\n\n`;
    msg += `Token: ${tokenCA.slice(0, 8)}...\n`;
    msg += `Status: ${result.success ? 'âœ… SUCCESS' : 'âŒ FAILED'}\n`;
    msg += `Message: ${result.message}\n`;
    msg += `Paid: ${fmtSol(result.paid || 0)} SOL\n`;
    msg += `Recipients: ${result.recipients || 0}\n`;
    
    if (result.transactions?.length > 0) {
      const successful = result.transactions.filter(t => t.success).length;
      const failed = result.transactions.filter(t => !t.success).length;
      msg += `\nTransactions: ${successful} âœ…, ${failed} âŒ`;
    }
    
    await ctx.reply(msg, adminHomeKeyboard());
  } catch (error) {
    await ctx.reply(`âŒ Payout failed: ${error.message}`, adminHomeKeyboard());
  }
});

bot.action(/^CALCPAY:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  await ctx.reply(`ðŸ§® Calculating payouts for token...`);
  
  try {
    const calculation = await calculatePayoutsForToken(tokenCA);
    
    let msg = `ðŸ§® PAYOUT CALCULATION\n\n`;
    msg += `Token: ${tokenCA.slice(0, 8)}...\n`;
    const token = getToken(tokenCA);
    msg += `Creator: ${token?.creator_tg_id || 'Unknown'}\n`;
    msg += `Creator Pool: ${fmtSol(calculation.pool || 0)} SOL\n`;
    msg += `Daily Payout (20%): ${fmtSol((calculation.pool || 0) * 0.20)} SOL\n`;
    msg += `Total Payout: ${fmtSol(calculation.totalPayout || 0)} SOL\n`;
    msg += `Eligible Recipients: ${calculation.recipients?.length || 0}\n`;
    msg += `Message: ${calculation.message}\n\n`;
    
    if (calculation.recipients?.length > 0) {
      msg += `Top 5 recipients:\n`;
      calculation.recipients.slice(0, 5).forEach((r, idx) => {
        msg += `${idx+1}. ${r.wallet.slice(0, 8)}...: ${fmtSol(r.amount)} SOL (${r.share.toFixed(2)}%)\n`;
      });
    }
    
    await ctx.reply(msg, adminTokenActionsKeyboard(tokenCA, backPage));
  } catch (error) {
    await ctx.reply(`âŒ Calculation failed: ${error.message}`, adminTokenActionsKeyboard(tokenCA, backPage));
  }
});

bot.action(/^AX:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  db.prepare(`UPDATE holders SET last_notified_at=0, last_notification_type=NULL WHERE ca=?`).run(tokenCA);
  
  await ctx.reply('âœ… Holder alerts reset for this token.', adminTokenActionsKeyboard(tokenCA, backPage));
});

bot.action(/^AA:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  db.prepare(`UPDATE tokens SET status='ACTIVE' WHERE ca=?`).run(tokenCA);
  
  await ctx.reply('âœ… Token activated.', adminTokenActionsKeyboard(tokenCA, backPage));
});

bot.action(/^AI:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  db.prepare(`UPDATE tokens SET status='INACTIVE' WHERE ca=?`).run(tokenCA);
  
  await ctx.reply('âœ… Token inactivated.', adminTokenActionsKeyboard(tokenCA, backPage));
});

bot.action(/^AD:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  const confirmKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback('âœ… YES DELETE', `AD_CONFIRM:${tokenCA}:${backPage}`)],
    [Markup.button.callback('âŒ Cancel', `${CB.ADM_TOKENS}:${backPage}`)],
  ]);
  
  await ctx.reply(
`âš ï¸ CONFIRM DELETE TOKEN âš ï¸

This will delete token ${tokenCA.slice(0, 8)}...
â€¢ Token record
â€¢ Meta data
â€¢ Holder registrations
â€¢ Deposit history
â€¢ Payout history
â€¢ Creator pool data

This action cannot be undone!

Type "DELETE" to confirm:`,
    confirmKeyboard
  );
});

bot.action(/^AD_CONFIRM:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  db.prepare('BEGIN TRANSACTION').run();
  try {
    const token = getToken(tokenCA);
    if (token) {
      // Creator pool auch lÃ¶schen
      db.prepare(`DELETE FROM creator_token_pools WHERE creator_tg_id=? AND token_ca=?`).run(token.creator_tg_id, tokenCA);
      db.prepare(`DELETE FROM creator_payouts WHERE creator_tg_id=? AND token_ca=?`).run(token.creator_tg_id, tokenCA);
    }
    
    db.prepare(`DELETE FROM tokens WHERE ca=?`).run(tokenCA);
    db.prepare(`DELETE FROM token_meta WHERE ca=?`).run(tokenCA);
    db.prepare(`DELETE FROM holders WHERE ca=?`).run(tokenCA);
    db.prepare(`DELETE FROM deposits WHERE ca=?`).run(tokenCA);
    db.prepare(`DELETE FROM payouts WHERE ca=?`).run(tokenCA);
    db.prepare('COMMIT').run();
    
    await ctx.reply(`âœ… Token ${tokenCA.slice(0, 8)}... deleted.`, Markup.inlineKeyboard([
      [Markup.button.callback('â¬…ï¸ Back to Tokens', `${CB.ADM_TOKENS}:${backPage}`)]
    ]));
  } catch (error) {
    db.prepare('ROLLBACK').run();
    await ctx.reply(`âŒ Delete failed: ${error.message}`, adminTokenActionsKeyboard(tokenCA, backPage));
  }
});

/* =========================
   CREATOR PANEL - FIXED!
========================= */
bot.action(CB.CRE_HOME, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  await safeEditOrReply(ctx, 'ðŸ‘¨â€ðŸŽ¨ Creator Panel', creatorHomeKeyboard());
});

bot.action(CB.CRE_REG, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  setState(ctx.from.id, { mode: 'creator_send_ca' });
  await ctx.reply(
`âž• Creator: Register Token ðŸª™

Send your token CA (mint address).

Important:
â€¢ Any Solana token can be registered ðŸ”—
â€¢ Minimum deposit: 0.01 SOL ðŸ’°
â€¢ Fee: 10% of deposit (goes to fee wallet) ðŸ“Š
â€¢ 90% goes to YOUR creator rewards pool ðŸŽ

Paste your token CA now:`,
{ parse_mode: 'Markdown' }
  );
});

async function renderCreatorTokens(ctx, page = 0) {
  const uid = ctx.from.id;
  const rows = db.prepare(`
    SELECT t.ca, t.status, t.created_at, 
           COALESCE(tm.display_name, tm.name) as name, 
           COALESCE(tm.display_symbol, tm.symbol) as symbol,
           (SELECT COALESCE(sol_amount,0) FROM creator_token_pools WHERE creator_tg_id=t.creator_tg_id AND token_ca=t.ca) as creator_pool
    FROM tokens t
    LEFT JOIN token_meta tm ON tm.ca=t.ca
    WHERE t.creator_tg_id=?
    ORDER BY t.created_at DESC
  `).all(uid);

  if (!rows.length) {
    return safeEditOrReply(ctx, 'ðŸ—‚ï¸ No tokens yet.\n\nRegister your first token to start! ðŸš€', creatorHomeKeyboard());
  }

  const { page: p, maxPage, slice } = paginateRows(rows, page, 5);

  let msg = `ðŸ—‚ï¸ My Tokens (${p + 1}/${maxPage + 1})\n\n`;
  slice.forEach((r, idx) => {
    const n = r.name || 'Unknown';
    const s = r.symbol ? `$${r.symbol}` : 'N/A';
    const creatorPool = Number(r.creator_pool || 0);
    const date = new Date(r.created_at).toLocaleDateString();
    
    msg += `${idx+1}. ${n} (${s})\n`;
    msg += `   Status: ${r.status}\n`;
    msg += `   Your Pool: ${fmtSol(creatorPool)} SOL ðŸŽ¯\n`;
    msg += `   CA: ${monospace(r.ca.slice(0, 16) + '...')}\n`;
    msg += `   Created: ${date}\n\n`;
  });
  
  const pickButtons = slice.map((r, idx) => [Markup.button.callback(`ðŸ“ Token ${idx + 1}`, `MAN:${r.ca}`)]);

  const nav = [];
  if (p > 0) nav.push(Markup.button.callback('â—€ï¸ Back', `${CB.CRE_LIST}:${p - 1}`));
  if (p < maxPage) nav.push(Markup.button.callback('Next â–¶ï¸', `${CB.CRE_LIST}:${p + 1}`));

  const kb = Markup.inlineKeyboard([
    ...pickButtons,
    ...(nav.length ? [nav] : []),
    [Markup.button.callback('âž• New Token', CB.CRE_REG)],
    [Markup.button.callback('ðŸ  Start', CB.HOME)],
  ]);

  await safeEditOrReply(ctx, msg, kb, 0);
}

bot.action(new RegExp(`^${CB.CRE_LIST}:(\\d+)$`), async (ctx) => {
  await safeAnswerCb(ctx);
  await renderCreatorTokens(ctx, Number(ctx.match[1] || 0));
});

bot.action(/^MAN:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) return ctx.reply('âš ï¸ Not your token.');

  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const creatorPool = getCreatorTokenPool(uid, tokenCA);
  const status = getToken(tokenCA)?.status || 'UNKNOWN';
  const holders = countHoldersForToken(tokenCA);
  const mc = Number(meta?.last_mc || 0);
  const totalFunded = getTotalFunded(tokenCA);

  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';

  await ctx.reply(
`ðŸ‘¨â€ðŸŽ¨ Manage Token

Name: ${displayName}
Symbol: ${displaySymbol ? `$${displaySymbol}` : 'N/A'}
CA: ${monospace(tokenCA)}

Status: ${status}
Market Cap: ${formatMc(mc)} ðŸ’Ž
YOUR Rewards Pool: ${fmtSol(creatorPool)} SOL ðŸŽ¯
Total Funded: ${fmtSol(totalFunded)} SOL
Registered holders: ${holders} ðŸ‘¥

Next step âœ…
- Deposit must be confirmed before posting.

Choose an action below:`,
    creatorManageKeyboard(tokenCA)
  );
});

/* =========================
   CREATOR ACTION HANDLERS - NEWLY ADDED!
========================= */

// Creator Stats Handler - AKTUALISIERT fÃ¼r Creator Pools
bot.action(/^CST:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('âš ï¸ Not your token.', creatorHomeKeyboard());
  }

  const token = getToken(tokenCA);
  const meta = getMeta(tokenCA);
  const creatorStats = getCreatorTokenStats(uid, tokenCA);
  const holderCount = countHoldersForToken(tokenCA);
  
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  // Get recent payouts from creator pool
  const recentPayouts = db.prepare(`
    SELECT COUNT(*) as count, COALESCE(SUM(sol_amount), 0) as total 
    FROM creator_payouts 
    WHERE creator_tg_id=? AND token_ca=? AND paid_at > ?
  `).get(uid, tokenCA, now() - 7 * 24 * 60 * 60 * 1000);

  const recentHolders = db.prepare(`
    SELECT COUNT(*) as count 
    FROM holders 
    WHERE ca=? AND registered_at > ?
  `).get(tokenCA, now() - 7 * 24 * 60 * 60 * 1000);

  const msg = `ðŸ“Š TOKEN STATISTICS

ðŸª™ Token: ${displayName} (${displaySymbol ? `$${displaySymbol}` : 'N/A'})
ðŸ“ˆ Status: ${token?.status || 'UNKNOWN'}
ðŸ“… Created: ${new Date(token?.created_at || 0).toLocaleDateString()}

ðŸ’° YOUR FINANCIAL (Creator-isoliert)
â€¢ Your Rewards Pool: ${fmtSol(creatorStats.pool)} SOL ðŸŽ¯
â€¢ Your Total Deposited: ${fmtSol(creatorStats.totalDeposited)} SOL
â€¢ Your Total Paid Out: ${fmtSol(creatorStats.totalPaid)} SOL
â€¢ Market Cap: ${formatMc(Number(meta?.last_mc || 0))}

ðŸ‘¥ HOLDERS
â€¢ Total Registered: ${holderCount}
â€¢ New (7 days): ${recentHolders?.count || 0}

ðŸŽ YOUR PAYOUTS
â€¢ Recent (7 days): ${recentPayouts?.count || 0} payments
â€¢ Amount: ${fmtSol(recentPayouts?.total || 0)} SOL

ðŸ”— Links:
â€¢ Pump.fun: ${meta?.pump_url || 'N/A'}
â€¢ Chart: ${meta?.dex_url || 'N/A'}`;

  await ctx.reply(msg, creatorManageKeyboard(tokenCA));
});

// Creator Report Handler - AKTUALISIERT
bot.action(/^REP:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('âš ï¸ Not your token.', creatorHomeKeyboard());
  }

  const token = getToken(tokenCA);
  const meta = getMeta(tokenCA);
  const creatorStats = getCreatorTokenStats(uid, tokenCA);
  const holderCount = countHoldersForToken(tokenCA);
  
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  // Get all deposits for this creator
  const deposits = db.prepare(`
    SELECT signature, sol_amount, fee_sol, reward_sol, created_at 
    FROM deposits 
    WHERE ca=? 
    ORDER BY created_at DESC
  `).all(tokenCA);
  
  // Get creator payouts
  const creatorPayouts = db.prepare(`
    SELECT holder_wallet, sol_amount, paid_at 
    FROM creator_payouts 
    WHERE creator_tg_id=? AND token_ca=?
    ORDER BY paid_at DESC
    LIMIT 10
  `).all(uid, tokenCA);
  
  let msg = `ðŸ“‹ TOKEN REPORT (Your Creator Pool)

ðŸª™ Token: ${displayName} (${displaySymbol ? `$${displaySymbol}` : 'N/A'})
ðŸ“ˆ Status: ${token?.status || 'UNKNOWN'}
ðŸ’° YOUR Rewards Pool: ${fmtSol(creatorStats.pool)} SOL ðŸŽ¯
ðŸ‘¥ Registered Holders: ${holderCount}

ðŸ“¥ YOUR DEPOSITS (${deposits.length}):\n`;
  
  deposits.forEach((dep, idx) => {
    if (idx < 5) {
      const date = new Date(dep.created_at).toLocaleDateString();
      msg += `â€¢ ${date}: ${fmtSol(dep.sol_amount)} SOL (Fee: ${fmtSol(dep.fee_sol)} SOL)\n`;
    }
  });
  
  if (deposits.length > 5) {
    msg += `â€¢ ... and ${deposits.length - 5} more deposits\n`;
  }
  
  msg += `\nðŸ“¤ YOUR RECENT PAYOUTS (${creatorPayouts.length}):\n`;
  
  if (creatorPayouts.length > 0) {
    creatorPayouts.forEach((payout, idx) => {
      if (idx < 3) {
        const date = new Date(payout.paid_at).toLocaleDateString();
        const walletShort = payout.holder_wallet.slice(0, 8) + '...' + payout.holder_wallet.slice(-4);
        msg += `â€¢ ${date}: ${fmtSol(payout.sol_amount)} SOL to ${walletShort}\n`;
      }
    });
    
    if (creatorPayouts.length > 3) {
      msg += `â€¢ ... and ${creatorPayouts.length - 3} more payouts\n`;
    }
  } else {
    msg += `â€¢ No payouts from your pool yet\n`;
  }
  
  msg += `\nðŸ“Š Your Total Deposited: ${fmtSol(creatorStats.totalDeposited)} SOL`;
  msg += `\nðŸ“Š Your Total Paid: ${fmtSol(creatorStats.totalPaid)} SOL`;
  msg += `\nðŸ“ˆ Market Cap: ${formatMc(Number(meta?.last_mc || 0))}`;

  await ctx.reply(msg, creatorManageKeyboard(tokenCA));
});

// Creator Holder Stats Handler
bot.action(/^CHS:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('âš ï¸ Not your token.', creatorHomeKeyboard());
  }

  const holders = db.prepare(`
    SELECT h.wallet, h.registered_at, h.total_paid, h.last_paid_at, h.username,
           (SELECT COUNT(*) FROM holders h2 WHERE h2.ca=h.ca) as total_holders
    FROM holders h
    WHERE h.ca=?
    ORDER BY h.registered_at DESC
    LIMIT 20
  `).all(tokenCA);
  
  const totalHolders = holders.length > 0 ? holders[0].total_holders : 0;
  const meta = getMeta(tokenCA);
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  let msg = `ðŸ‘¤ HOLDER STATISTICS

ðŸª™ Token: ${displayName} (${displaySymbol ? `$${displaySymbol}` : 'N/A'})
ðŸ“Š Total Holders: ${totalHolders}

ðŸ“‹ RECENT REGISTRATIONS:\n`;
  
  if (holders.length > 0) {
    holders.forEach((holder, idx) => {
      if (idx < 10) {
        const walletShort = holder.wallet.slice(0, 8) + '...' + holder.wallet.slice(-4);
        const registered = new Date(holder.registered_at).toLocaleDateString();
        const holdHours = ((now() - holder.registered_at) / (1000 * 60 * 60)).toFixed(1);
        const totalPaid = fmtSol(holder.total_paid || 0);
        
        msg += `\n${idx+1}. ${walletShort}`;
        if (holder.username) msg += ` (@${holder.username})`;
        msg += `\n   ðŸ“… Registered: ${registered}`;
        msg += `\n   â° Hold time: ${holdHours}h`;
        msg += `\n   ðŸ’° Earned: ${totalPaid} SOL`;
      }
    });
    
    if (holders.length > 10) {
      msg += `\n\n... and ${holders.length - 10} more holders`;
    }
  } else {
    msg += `\nNo holders registered yet.`;
  }
  
  // Get top earners from this creator's pool
  const topEarners = db.prepare(`
    SELECT h.wallet, h.total_paid, h.username
    FROM holders h
    WHERE h.ca=? AND h.total_paid > 0
    ORDER BY h.total_paid DESC
    LIMIT 5
  `).all(tokenCA);
  
  if (topEarners.length > 0) {
    msg += `\n\nðŸ† TOP EARNERS:\n`;
    topEarners.forEach((earner, idx) => {
      const walletShort = earner.wallet.slice(0, 8) + '...' + earner.wallet.slice(-4);
      msg += `\n${idx+1}. ${walletShort}: ${fmtSol(earner.total_paid || 0)} SOL`;
      if (earner.username) msg += ` (@${earner.username})`;
    });
  }

  await ctx.reply(msg, creatorManageKeyboard(tokenCA));
});

// Creator Edit Display Handler
bot.action(/^EDN:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('âš ï¸ Not your token.', creatorHomeKeyboard());
  }

  const meta = getMeta(tokenCA);
  const currentName = meta?.display_name || meta?.name || 'Unknown';
  const currentSymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  // Set state for text handler
  setState(uid, { mode: 'creator_edit_name', tempTokenCA: tokenCA });
  
  await ctx.reply(
`ðŸŽ¨ EDIT DISPLAY NAME/SYMBOL

Current name: ${currentName}
Current symbol: ${currentSymbol}

Please send the NEW name (max 64 characters):

Example: "WhiteMeme Token", "CryptoPump", etc.`,
    creatorManageKeyboard(tokenCA)
  );
});

// Creator Deactivate Handler
bot.action(/^DEA:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('âš ï¸ Not your token.', creatorHomeKeyboard());
  }

  const token = getToken(tokenCA);
  if (!token) return ctx.reply('âš ï¸ Token not found.', creatorHomeKeyboard());
  
  const meta = getMeta(tokenCA);
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  
  const confirmKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback('âœ… YES, DEACTIVATE', `DEA_CONFIRM:${tokenCA}`)],
    [Markup.button.callback('âŒ Cancel', `MAN:${tokenCA}`)],
  ]);
  
  await ctx.reply(
`ðŸš« DEACTIVATE TOKEN âš ï¸

Token: ${displayName}
CA: ${tokenCA.slice(0, 12)}...

âš ï¸ WARNING:
â€¢ Token will be marked INACTIVE
â€¢ No more payouts from YOUR pool will be processed
â€¢ Your existing creator pool remains
â€¢ Holders cannot earn new rewards from your pool
â€¢ Can be reactivated by admin

Are you sure you want to deactivate this token?`,
    confirmKeyboard
  );
});

// Creator Deactivate Confirmation Handler
bot.action(/^DEA_CONFIRM:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('âš ï¸ Not your token.', creatorHomeKeyboard());
  }

  db.prepare(`UPDATE tokens SET status='INACTIVE' WHERE ca=?`).run(tokenCA);
  
  const meta = getMeta(tokenCA);
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  
  await ctx.reply(
`âœ… Token deactivated: ${displayName}

The token has been marked as INACTIVE.
â€¢ No new payouts from YOUR pool will be processed
â€¢ Your existing creator pool remains
â€¢ Holders will be notified
â€¢ Contact admin to reactivate`,
    creatorManageKeyboard(tokenCA)
  );
});

/* =========================
   CONFIRM / CANCEL
========================= */
bot.action(/^CONF:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  const t = getToken(tokenCA);
  if (!t) return ctx.reply('âš ï¸ Token not found.');
  if (t.creator_tg_id !== uid) return ctx.reply('âš ï¸ Only the creator can confirm.');

  db.prepare(`UPDATE tokens SET status='PENDING_PAYMENT' WHERE ca=?`).run(tokenCA);

  await ctx.reply(
`âœ… Token confirmed! ðŸŽ‰

ðŸ’¸ Next step: Deposit required
Send SOL to the Reward Wallet:
${monospace(REWARD_WALLET)}

Minimum: 0.01 SOL ðŸ’°
Fee: 10% (sent to fee wallet) ðŸ“Š
Rewards: 90% added to YOUR creator pool ðŸŽ¯

Then open "Deposit / Check Payment" and paste your Solscan TX link. ðŸ”Ž`,
    creatorManageKeyboard(tokenCA)
  );
});

bot.action('CXL', async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  await ctx.reply('âŒ Cancelled.', creatorHomeKeyboard());
});

/* =========================
   DEPOSIT / CHECK (AKTUALISIERT fÃ¼r Creator Pools)
========================= */
bot.action(/^DEP:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) return ctx.reply('âš ï¸ Not your token.');
  const t = getToken(tokenCA);
  if (!t) return ctx.reply('âš ï¸ Token not found.');
  if (t.status === 'PENDING_CONFIRM') return ctx.reply('âš ï¸ Please confirm the token first.');

  setState(uid, { mode: 'wait_payment_tx', tempTokenCA: tokenCA });

  await ctx.reply(
`ðŸ’¸ Deposit / Payment

Send SOL to Reward Wallet:
${monospace(REWARD_WALLET)}

Requirements:
â€¢ Minimum deposit: 0.01 SOL ðŸ’°
â€¢ Service fee: 10% (sent to fee wallet) ðŸ“Š
â€¢ Rewards added: 90% to YOUR creator pool ðŸŽ¯

How to pay:
1. Send SOL to address above
2. Go to solscan.io
3. Copy the transaction link
4. Paste it here
5. Click "Check Payment" button

Now paste your Solscan TX link here. ðŸ”`,
{ 
  parse_mode: 'Markdown',
  reply_markup: paymentKeyboard(tokenCA).reply_markup
}
  );
});

bot.action(/^CHK:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('âš ï¸ Not your token.', creatorManageKeyboard(tokenCA));
  }

  const s = getState(uid);
  if (!s?.tempSig || s?.tempTokenCA !== tokenCA) {
    return ctx.reply('âš ï¸ Please paste your Solscan TX link first, then click "Check Payment".', creatorManageKeyboard(tokenCA));
  }

  const sig = s.tempSig;

  const already = db.prepare(`SELECT signature FROM deposits WHERE signature=?`).get(sig);
  if (already) {
    clearState(uid);
    return ctx.reply('âœ… Transaction already confirmed and processed.', creatorManageKeyboard(tokenCA));
  }

  let verification;
  try {
    verification = await verifyDepositTx(sig, REWARD_WALLET);
  } catch (e) {
    return ctx.reply(`âš ï¸ Could not verify transaction. Error: ${String(e?.message || e)}`, creatorManageKeyboard(tokenCA));
  }

  if (!verification.ok) {
    return ctx.reply(`âš ï¸ Payment not confirmed. Reason: ${verification.reason}`, creatorManageKeyboard(tokenCA));
  }

  const solAmount = verification.solAmount;
  if (solAmount < 0.01) {
    return ctx.reply('âš ï¸ Deposit too small. Minimum is 0.01 SOL.', creatorManageKeyboard(tokenCA));
  }

  const feeSol = solAmount * 0.10;
  const rewardSol = solAmount * 0.90;

  let feeSig = null;
  try {
    feeSig = await sendFeeTransfer(feeSol);
    console.log(`âœ… Fee sent: ${feeSig}`);
  } catch (feeError) {
    console.log(`âš ï¸ Fee transfer failed: ${feeError.message}`);
    return ctx.reply('âš ï¸ Fee transfer failed. Please try again.', creatorManageKeyboard(tokenCA));
  }

  db.prepare(`
    INSERT INTO deposits (signature, ca, from_wallet, sol_amount, fee_sol, reward_sol, fee_sig, created_at, creator_tg_id)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(sig, tokenCA, verification.fromWallet || '', solAmount, feeSol, rewardSol, feeSig || '', now(), uid);

  // WICHTIG: Creator-Pool aktualisieren (nur dieser Creator!)
  const token = getToken(tokenCA);
  if (token) {
    updateCreatorTokenPool(token.creator_tg_id, tokenCA, rewardSol);
  }

  db.prepare(`UPDATE tokens SET status='ACTIVE' WHERE ca=?`).run(tokenCA);

  await refreshMetaPriority(tokenCA);

  const meta = getMeta(tokenCA);
  if (!meta?.base_mc || Number(meta.base_mc) <= 0) {
    try {
      const pair = await fetchDexPair(tokenCA);
      const mc = pairMarketCap(pair);
      if (mc > 0) {
        db.prepare(`UPDATE token_meta SET base_mc=?, last_mc=?, last_checked_at=? WHERE ca=?`)
          .run(mc, mc, now(), tokenCA);
      }
    } catch {}
  }

  clearState(uid);

  console.log(`ðŸš€ STARTING POST after payment for: ${tokenCA}`);
  await postToChannelAndGroups(tokenCA, 'âœ… Activated (deposit confirmed) ðŸŽ‰');

  const newCreatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  
  await ctx.reply(
`âœ… Deposit confirmed! ðŸŽ‰

Deposit: ${fmtSol(solAmount)} SOL ðŸ’°
Added to YOUR pool: ${fmtSol(rewardSol)} SOL ðŸŽ¯
Your pool now: ${fmtSol(newCreatorPool)} SOL

ðŸš€ Post has been sent to Channel + Groups!

âœ… Token is now active and will be monitored.
ðŸŽ—ï¸ Auto-posts at 2x, 5x, 10x milestones!
ðŸ’° Payouts will ONLY come from YOUR creator pool.`,
    creatorManageKeyboard(tokenCA)
  );
});

/* =========================
   TEXT HANDLER (flows)
========================= */
bot.on('text', async (ctx) => {
  const uid = ctx.from.id;
  const s = getState(uid);
  const text = (ctx.message?.text || '').trim();

  if (!text || text.startsWith('/')) return;

  // CREATOR register
  if (s?.mode === 'creator_send_ca') {
    const ca = extractFirstPubkey(text);
    if (!ca) return ctx.reply('âš ï¸ Invalid mint address. Please paste only the CA.');

    if (tokenExists(ca)) {
      clearState(uid);
      return ctx.reply('âš ï¸ Token already exists. Open "My Tokens".', creatorHomeKeyboard());
    }

    db.prepare(`
      INSERT INTO tokens (ca, creator_tg_id, creator_username, status, created_at)
      VALUES (?, ?, ?, 'PENDING_CONFIRM', ?)
    `).run(ca, uid, ctx.from.username || '', now());

    const meta = await refreshMetaPriority(ca);
    clearState(uid);

    const name = meta?.display_name || meta?.name || 'Unknown';
    const symbol = meta?.display_symbol || meta?.symbol || 'N/A';
    const logo = meta?.logo_url;

    let confirmationMsg = `ðŸª™ Confirm this token\n\n`;
    if (logo) {
      confirmationMsg += `âœ… Token information retrieved successfully!\n\n`;
    }
    
    confirmationMsg += `Name: ${name}\n`;
    confirmationMsg += `Symbol: ${symbol ? `$${symbol}` : 'N/A'}\n`;
    confirmationMsg += `CA: ${monospace(ca)}\n\n`;
    confirmationMsg += `Posting happens ONLY after deposit is confirmed âœ…\n\n`;
    confirmationMsg += `Payment wallet: ${monospace(REWARD_WALLET)}`;

    if (logo) {
      await ctx.replyWithPhoto(logo, {
        caption: confirmationMsg,
        parse_mode: 'Markdown',
        reply_markup: tokenConfirmKeyboard(ca).reply_markup
      });
    } else {
      await ctx.reply(confirmationMsg, {
        parse_mode: 'Markdown',
        reply_markup: tokenConfirmKeyboard(ca)
      });
    }
    
    return;
  }

  // HOLDER send token
  if (s?.mode === 'holder_send_token') {
    const ca = extractFirstPubkey(text);
    if (!ca) return ctx.reply('âš ï¸ Invalid token CA.');

    if (!tokenExists(ca)) return ctx.reply('âš ï¸ This token is not registered yet. Ask the creator to register it first.');

    try {
      const supply = await getMintSupplyAndDecimals(ca);
      const supplyUi = Number(supply.uiAmount || 0);
      const minUi = supplyUi * MIN_HOLDER_PCT;
      
      await ctx.reply(`ðŸ” Checking token supply...\n\nMinimum required: ${minUi.toFixed(4)} tokens ðŸª™\n\nNow send your wallet address to check your balance.`);
      
      setState(uid, { 
        mode: 'holder_send_wallet', 
        tempTokenCA: ca,
        tempMinRequired: minUi,
        tempSupplyUi: supplyUi
      });
    } catch (e) {
      await ctx.reply('âš ï¸ Could not fetch token supply. Please try again later.');
    }
    return;
  }

  // HOLDER send wallet
  if (s?.mode === 'holder_send_wallet') {
    const ca = s.tempTokenCA;
    const minRequired = s.tempMinRequired || 0;
    const wallet = extractFirstPubkey(text);
    if (!wallet) return ctx.reply('âš ï¸ Invalid wallet address.');

    try {
      const balance = await getWalletTokenBalanceUi(wallet, ca);
      const supplyUi = s.tempSupplyUi || 0;
      
      if (balance < minRequired) {
        const percentHeld = supplyUi > 0 ? (balance / supplyUi * 100).toFixed(6) : '0';
        const requiredPercent = (MIN_HOLDER_PCT * 100).toFixed(4);
        
        await ctx.reply(
`âš ï¸ Insufficient Balance

You hold: ${balance.toFixed(4)} tokens ðŸª™
Required: ${minRequired.toFixed(4)} tokens ðŸª™

Percentage held: ${percentHeld}%
Required: ${requiredPercent}%

You must hold at least ${requiredPercent}% of total supply to register.

Please acquire more tokens and try again.`,
          holderHomeKeyboard()
        );
        
        db.prepare(`
          UPDATE holders 
          SET last_notified_at=?, last_notification_type=? 
          WHERE ca=? AND wallet=?
        `).run(now(), 'insufficient_balance', ca, wallet);
        
        clearState(uid);
        return;
      }
      
      db.prepare(`
        INSERT INTO holders (ca, tg_id, username, wallet, registered_at)
        VALUES (?, ?, ?, ?, ?)
        ON CONFLICT(ca, wallet) DO UPDATE SET
          tg_id=excluded.tg_id,
          username=excluded.username,
          registered_at=excluded.registered_at,
          last_notified_at=0,
          last_notification_type=NULL
      `).run(ca, uid, ctx.from.username || '', wallet, now());

      // Send registration DM
      await sendRegistrationDM(uid, ca, wallet, balance, supplyUi);

      clearState(uid);

      const tm = getMeta(ca) || await refreshMetaPriority(ca);
      const displayName = tm?.display_name || tm?.name || 'Unknown';
      const displaySymbol = tm?.display_symbol || tm?.symbol || 'N/A';

      return ctx.reply(
`âœ… Registered successfully! ðŸŽ‰

Token: ${displayName} (${displaySymbol ? `$${displaySymbol}` : 'N/A'})
CA: ${monospace(ca)}
Wallet: ${monospace(wallet)}
Your balance: ${balance.toFixed(4)} tokens âœ…

âœ… Eligibility Rules
- Hold at least ${MIN_HOLD_HOURS} hours â°
- Hold at least ${(MIN_HOLDER_PCT * 100).toFixed(4)}% of supply ðŸª™
- Do NOT sell during the holding period ðŸ“‰

ðŸ’Ž The longer you hold, the more rewards you earn!

ðŸ“¨ You will receive DM notifications for payouts!`,
        holderHomeKeyboard()
      );
    } catch (e) {
      await ctx.reply(`âš ï¸ Error checking balance: ${e.message}`);
      clearState(uid);
    }
    return;
  }

  // HOLDER remove token
  if (s?.mode === 'holder_remove_token') {
    const ca = extractFirstPubkey(text);
    if (!ca) return ctx.reply('âš ï¸ Invalid token CA.');
    setState(uid, { mode: 'holder_remove_wallet', tempTokenCA: ca });
    return ctx.reply('ðŸ—‘ï¸ Now send the wallet address to remove. ðŸ‘›\n\nPaste your wallet address:');
  }

  // HOLDER remove wallet
  if (s?.mode === 'holder_remove_wallet') {
    const ca = s.tempTokenCA;
    const wallet = extractFirstPubkey(text);
    if (!wallet) return ctx.reply('âš ï¸ Invalid wallet address.');

    const res = db.prepare(`DELETE FROM holders WHERE ca=? AND wallet=? AND tg_id=?`).run(ca, wallet, uid);
    clearState(uid);

    if (res.changes > 0) return ctx.reply('âœ… Registration removed.', holderHomeKeyboard());
    return ctx.reply('âš ï¸ Not found. Please double-check token + wallet.', holderHomeKeyboard());
  }

  // CREATOR edit name
  if (s?.mode === 'creator_edit_name') {
    const tokenCA = s.tempTokenCA;
    const uid = ctx.from.id;
    
    if (!creatorOwnsToken(uid, tokenCA)) {
      clearState(uid);
      return ctx.reply('âš ï¸ Not your token.', creatorHomeKeyboard());
    }

    const newName = text.slice(0, 64);
    setState(uid, { mode: 'creator_edit_symbol', tempTokenCA: tokenCA, tempName: newName });
    
    await ctx.reply(
`âœ… Name set to: ${newName}

Now send the new symbol (without $, max 15 characters):

Example: WHITE, MEME, BOT`,
      creatorManageKeyboard(tokenCA)
    );
    return;
  }

  // CREATOR edit symbol
  if (s?.mode === 'creator_edit_symbol') {
    const tokenCA = s.tempTokenCA;
    const uid = ctx.from.id;
    const newName = s.tempName;
    
    if (!creatorOwnsToken(uid, tokenCA)) {
      clearState(uid);
      return ctx.reply('âš ï¸ Not your token.', creatorHomeKeyboard());
    }

    const newSymbol = text.replace(/\$/g, '').slice(0, 15);
    
    db.prepare(`
      UPDATE token_meta 
      SET display_name=?, display_symbol=?
      WHERE ca=?
    `).run(newName, newSymbol, tokenCA);
    
    clearState(uid);
    
    await ctx.reply(
`âœ… Display name/symbol updated!

New name: ${newName}
New symbol: ${newSymbol}

Posts will now show: ${newName} #${newSymbol}`,
      creatorManageKeyboard(tokenCA)
    );
    return;
  }

  // PAYMENT: waiting tx
  if (s?.mode === 'wait_payment_tx') {
    const sig = extractSignatureFromText(text);
    if (!sig) return ctx.reply('âš ï¸ Please paste a Solscan TX link or a transaction signature.');
    
    setState(uid, { mode: 'wait_payment_check', tempTokenCA: s.tempTokenCA, tempSig: sig });
    
    await ctx.reply(
`âœ… TX received! ðŸ”

Transaction signature: ${monospace(sig.slice(0, 16) + '...')}

Now click "Check Payment" button to confirm.`,
{ 
  parse_mode: 'Markdown',
  reply_markup: paymentKeyboard(s.tempTokenCA).reply_markup
}
    );
    return;
  }
});

/* =========================
   REST OF FUNCTIONS
========================= */
function getToken(ca) { return db.prepare(`SELECT * FROM tokens WHERE ca=?`).get(ca); }
function getMeta(ca) { return db.prepare(`SELECT * FROM token_meta WHERE ca=?`).get(ca); }
function tokenExists(ca) { return !!getToken(ca); }
function creatorOwnsToken(uid, ca) {
  return !!db.prepare(`SELECT ca FROM tokens WHERE ca=? AND creator_tg_id=?`).get(ca, uid);
}

// Behalte alte Funktion fÃ¼r KompatibilitÃ¤t, aber verwende Creator-Pools fÃ¼r Payouts
function getRewardsPool(ca) {
  const dep = db.prepare(`SELECT COALESCE(SUM(reward_sol),0) AS pool FROM deposits WHERE ca=?`).get(ca);
  const paid = db.prepare(`SELECT COALESCE(SUM(sol_amount),0) AS paid FROM payouts WHERE ca=?`).get(ca);
  return Math.max(0, Number(dep.pool || 0) - Number(paid.paid || 0));
}

function getTotalFunded(ca) {
  const row = db.prepare(`SELECT COALESCE(SUM(sol_amount),0) AS total FROM deposits WHERE ca=?`).get(ca);
  return Number(row.total || 0);
}

function getFeesTotal(ca) {
  const row = db.prepare(`SELECT COALESCE(SUM(fee_sol),0) AS total FROM deposits WHERE ca=?`).get(ca);
  return Number(row.total || 0);
}

function countHoldersForToken(ca) {
  const r = db.prepare(`SELECT COUNT(*) AS c FROM holders WHERE ca=?`).get(ca);
  return Number(r?.c || 0);
}

/* =========================
   LAUNCH BOT - VERBESSERTE VERSION!
========================= */
async function launchBot() {
  console.log('ðŸ¤– Starting ðŸŽ­ WHITEMEME Bot...');
  console.log(`ðŸ“¢ Channel: ${CHANNEL_ID}`);
  console.log(`ðŸ’° Reward Wallet: ${REWARD_WALLET}`);
  console.log(`ðŸ’³ Fee Wallet: ${FEE_WALLET}`);
  console.log(`ðŸ”§ Callback Keys:`, CB);
  
  // RUN AUTO MIGRATION FIRST
  runAutoMigration();
  
  try {
    console.log('ðŸ“¢ Starting broadcast worker...');
    startBroadcastWorker();
    
    console.log('ðŸ“ˆ Starting milestone checker...');
    startMilestoneChecker();
    
    console.log('â° Starting auto-payout scheduler...');
    startAutoPayoutScheduler();
    
    await bot.launch({ dropPendingUpdates: true });
    console.log('âœ… Bot running! âœ…');
    
    try {
      const chat = await bot.telegram.getChat(CHANNEL_ID);
      console.log(`âœ… Channel accessible: ${chat.title || 'Unknown'}`);
      
      const adminMsg = `ðŸ¤– ðŸŽ­ WHITEMEME Bot started âœ…\n\nâ€¢ Channel: ${chat.title || CHANNEL_ID}\nâ€¢ Time: ${new Date().toLocaleString()}\nâ€¢ Posts sent IMMEDIATELY! ðŸš€\nâ€¢ Reward Wallet: ${monospace(REWARD_WALLET)}\nâ€¢ Creator-isolated Pools: ACTIVATED ðŸŽ¯\nâ€¢ Bonded Posting: ACTIVATED ðŸŽ—ï¸\nâ€¢ Auto-Payouts: 20:00 UTC daily â°\nâ€¢ Holder DM Notifications: ENABLED ðŸ“¨`;
      for (const adminId of ADMIN_IDS) {
        try {
          await bot.telegram.sendMessage(adminId, adminMsg, { parse_mode: 'Markdown' });
        } catch {}
      }
    } catch (e) {
      console.log(`âš ï¸ Channel not accessible: ${e.message}`);
      console.log('âš ï¸ Make sure bot is admin in the channel!');
    }
    
    console.log('ðŸš€ Bot fully started and ready!');
    console.log('âœ… ALL FIXES APPLIED:');
    console.log('  â€¢ Creator "My Tokens" panel working');
    console.log('  â€¢ Admin "Manage Tokens" FIXED (unique callback data)');
    console.log('  â€¢ Creator Stats, Report, Holder Stats, Edit Display FIXED');
    console.log('  â€¢ All action handlers implemented');
    console.log('  â€¢ New post format with CA address');
    console.log('  â€¢ Auto-migration system for database');
    console.log('ðŸŽ¯ CRITICAL FIX: Creator-isolated reward pools ACTIVATED');
    console.log('ðŸ“¨ Holder DM System: ACTIVE');
    console.log('ðŸŽ¯ Payouts now ONLY from creator own pool!');
    console.log('ðŸŽ—ï¸ Bonded Posting System: ACTIVATED');
    console.log('ðŸ“ˆ Milestone Auto-Posts: 2x/5x/10x ENABLED');
    console.log('â° Auto-Payouts: 20:00 UTC daily');
    
  } catch (e) {
    console.log('âŒ Bot start failed:', String(e?.message || e));
    console.log('ðŸ”„ Restarting in 10 seconds...');
    setTimeout(launchBot, 10000);
  }
}

launchBot();

process.once('SIGINT', () => {
  console.log('ðŸ›‘ SIGINT received, stopping bot...');
  bot.stop('SIGINT');
  process.exit(0);
});

process.once('SIGTERM', () => {
  console.log('ðŸ›‘ SIGTERM received, stopping bot...');
  bot.stop('SIGTERM');
  process.exit(0);
});
