/**
 * üé≠ WHITEMEME BOT ‚Äî COMPLETELY FIXED VERSION
 * 
 * ‚úÖ ALL FIXES APPLIED:
 * - FIXED: Admin Panel "Manage Tokens" now working
 * - FIXED: Creator Panel "Stats", "Report", "Holder Stats", "Edit Display" now working
 * - FIXED: All missing action handlers added
 * - FIXED: Proper callback routing for all buttons
 * - FIXED: Deactivate functionality
 * - FIXED: Edit display name/symbol flow
 * - FIXED: Admin token navigation with unique callback data
 * - FIXED: New post format with CA address
 * - ADDED: Debug logging for troubleshooting
 * - FIXED: Creator-isolated reward pools (CRITICAL FIX)
 * - FIXED: Database migration system with auto-fix
 */

require('dotenv').config();

const path = require('path');
const os = require('os');
const axios = require('axios');

const bs58pkg = require('bs58');
const bs58 = bs58pkg.default || bs58pkg;

const { Telegraf, Markup } = require('telegraf');
const Database = require('better-sqlite3');

const {
  Connection,
  PublicKey,
  Keypair,
  LAMPORTS_PER_SOL,
  SystemProgram,
  Transaction,
  sendAndConfirmTransaction,
} = require('@solana/web3.js');

/* =========================
   CONFIG
========================= */
const BOT_TOKEN = (process.env.BOT_TOKEN || '').trim();
const CHANNEL_ID_RAW = String((process.env.CHANNEL_ID || '').trim());
const RPC_URL = (process.env.RPC_URL || 'https://api.mainnet-beta.solana.com').trim();

const CHANNEL_LINK = (process.env.CHANNEL_LINK || '').trim();
const TWITTER_LINK = (process.env.TWITTER_LINK || '').trim();

const PAYOUT_SECRET_BASE58 = (process.env.PAYOUT_SECRET_BASE58 || '').trim();
const FEE_WALLET = (process.env.FEE_WALLET || '').trim();

const ADMIN_IDS = (process.env.ADMIN_IDS || '')
  .split(',')
  .map(x => x.trim())
  .filter(Boolean);

const BROADCAST_DELAY_MS = Number(process.env.BROADCAST_DELAY_MS || 450);
const META_REFRESH_MS = Number(process.env.META_REFRESH_MS || 90_000);
const HTTP_TIMEOUT_MS = Number(process.env.HTTP_TIMEOUT_MS || 15_000);

const MIN_HOLDER_PCT = Number(process.env.MIN_HOLDER_PCT || 0.0004);
const MIN_HOLD_HOURS = Number(process.env.MIN_HOLD_HOURS || 24);
const DAILY_PAYOUT_PCT = Number(process.env.DAILY_PAYOUT_PCT || 0.20);

const MIN_PAYOUT_SOL = Number(process.env.MIN_PAYOUT_SOL || 0.00001);
const MAX_PAYOUTS_PER_ROUND = Number(process.env.MAX_PAYOUTS_PER_ROUND || 300);
const MAX_PAYOUT_RECIPIENTS = Number(process.env.MAX_PAYOUT_RECIPIENTS || 80);
const TX_DELAY_MS = Number(process.env.TX_DELAY_MS || 350);
const PAYOUT_WALLET_BUFFER_LAMPORTS = Number(process.env.PAYOUT_WALLET_BUFFER_LAMPORTS || 2_000_000);

// Performance & Retry config
const MAX_RETRIES = 3;
const RETRY_DELAY = 2000;
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

function normalizeChannelId(x) {
  const v = String(x || '').trim();
  if (!v) return '';
  if (v.startsWith('@')) return v;
  return v;
}

const CHANNEL_ID = normalizeChannelId(CHANNEL_ID_RAW);

if (!BOT_TOKEN || !CHANNEL_ID) {
  console.log('‚ùå ERROR: Missing BOT_TOKEN or CHANNEL_ID in .env');
  process.exit(1);
}
if (!PAYOUT_SECRET_BASE58) {
  console.log('‚ùå ERROR: Missing PAYOUT_SECRET_BASE58 in .env');
  process.exit(1);
}
if (!FEE_WALLET) {
  console.log('‚ùå ERROR: Missing FEE_WALLET in .env');
  process.exit(1);
}

/* =========================
   SOLANA
========================= */
let payer;
try {
  const secret = bs58.decode(PAYOUT_SECRET_BASE58);
  payer = Keypair.fromSecretKey(secret);
} catch {
  console.log('‚ùå ERROR: PAYOUT_SECRET_BASE58 is invalid.');
  process.exit(1);
}

const REWARD_WALLET = payer.publicKey.toBase58();
const connection = new Connection(RPC_URL, 'confirmed');
const bot = new Telegraf(BOT_TOKEN);

/* =========================
   DATABASE
========================= */
const dbPath = (process.env.DB_PATH && process.env.DB_PATH.trim())
  ? process.env.DB_PATH.trim()
  : path.join(os.tmpdir(), 'whitememe.db');

const db = new Database(dbPath);
db.pragma('journal_mode = WAL');
db.pragma('synchronous = NORMAL');
db.pragma('busy_timeout = 8000');

console.log('üíæ Database Path:', dbPath);
console.log('üì¢ Channel ID:', CHANNEL_ID);
console.log('üí∞ Reward Wallet:', REWARD_WALLET);

/* =========================
   DATABASE SCHEMA + MIGRATION
========================= */
db.exec(`
CREATE TABLE IF NOT EXISTS tokens (
  ca TEXT PRIMARY KEY,
  creator_tg_id INTEGER NOT NULL,
  creator_username TEXT,
  status TEXT NOT NULL DEFAULT 'PENDING_CONFIRM',
  created_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS token_meta (
  ca TEXT PRIMARY KEY,
  name TEXT,
  symbol TEXT,
  pump_url TEXT,
  dex_url TEXT,
  pair_address TEXT,
  on_dex_at_reg INTEGER DEFAULT 0,
  bonded_posted INTEGER DEFAULT 0,
  base_mc REAL DEFAULT 0,
  last_x_posted INTEGER DEFAULT 0,
  last_mc REAL DEFAULT 0,
  last_checked_at INTEGER DEFAULT 0,
  logo_url TEXT,
  display_name TEXT,
  display_symbol TEXT
);

-- NEUE TABELLE: Creator-Pools f√ºr jeden Creator-Token
CREATE TABLE IF NOT EXISTS creator_token_pools (
  creator_tg_id INTEGER NOT NULL,
  token_ca TEXT NOT NULL,
  sol_amount REAL NOT NULL DEFAULT 0,
  last_updated INTEGER NOT NULL,
  PRIMARY KEY (creator_tg_id, token_ca)
);

-- NEUE TABELLE: Creator-Payouts f√ºr Tracking
CREATE TABLE IF NOT EXISTS creator_payouts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  creator_tg_id INTEGER NOT NULL,
  token_ca TEXT NOT NULL,
  holder_wallet TEXT NOT NULL,
  sol_amount REAL NOT NULL,
  paid_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS deposits (
  signature TEXT PRIMARY KEY,
  ca TEXT NOT NULL,
  from_wallet TEXT,
  sol_amount REAL NOT NULL,
  fee_sol REAL NOT NULL,
  reward_sol REAL NOT NULL,
  fee_sig TEXT,
  created_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS payouts (
  payout_sig TEXT PRIMARY KEY,
  ca TEXT NOT NULL,
  to_wallet TEXT NOT NULL,
  sol_amount REAL NOT NULL,
  created_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS holders (
  ca TEXT NOT NULL,
  tg_id INTEGER NOT NULL,
  username TEXT,
  wallet TEXT NOT NULL,
  registered_at INTEGER NOT NULL,
  last_notified_at INTEGER DEFAULT 0,
  last_notification_type TEXT,
  total_paid REAL DEFAULT 0,
  last_paid_at INTEGER DEFAULT 0,
  PRIMARY KEY (ca, wallet)
);

CREATE TABLE IF NOT EXISTS groups (
  chat_id TEXT PRIMARY KEY,
  title TEXT,
  active INTEGER DEFAULT 1,
  created_at INTEGER NOT NULL,
  last_error TEXT
);

CREATE TABLE IF NOT EXISTS settings (
  k TEXT PRIMARY KEY,
  v TEXT
);
`);

function tableHasColumn(table, col) {
  const rows = db.prepare(`PRAGMA table_info(${table})`).all();
  return rows.some(r => r.name === col);
}

function addColumnIfMissing(table, col, defSql) {
  if (!tableHasColumn(table, col)) {
    db.exec(`ALTER TABLE ${table} ADD COLUMN ${col} ${defSql}`);
    console.log(`üîß DB MIGRATION: added ${table}.${col}`);
  }
}

addColumnIfMissing('token_meta', 'on_dex_at_reg', 'INTEGER DEFAULT 0');
addColumnIfMissing('token_meta', 'bonded_posted', 'INTEGER DEFAULT 0');
addColumnIfMissing('token_meta', 'base_mc', 'REAL DEFAULT 0');
addColumnIfMissing('token_meta', 'last_x_posted', 'INTEGER DEFAULT 0');
addColumnIfMissing('token_meta', 'last_mc', 'REAL DEFAULT 0');
addColumnIfMissing('token_meta', 'last_checked_at', 'INTEGER DEFAULT 0');
addColumnIfMissing('token_meta', 'logo_url', 'TEXT');
addColumnIfMissing('token_meta', 'display_name', 'TEXT');
addColumnIfMissing('token_meta', 'display_symbol', 'TEXT');
addColumnIfMissing('groups', 'last_error', 'TEXT');
addColumnIfMissing('holders', 'last_notified_at', 'INTEGER DEFAULT 0');
addColumnIfMissing('holders', 'last_notification_type', 'TEXT');
addColumnIfMissing('holders', 'total_paid', 'REAL DEFAULT 0');
addColumnIfMissing('holders', 'last_paid_at', 'INTEGER DEFAULT 0');

/* =========================
   AUTO MIGRATION SYSTEM - NEU!
========================= */
function runAutoMigration() {
  console.log('üîß Running auto-migration checks...');
  
  try {
    // 1. Check if deposits table has creator_tg_id column
    const depositsColumns = db.prepare(`
      SELECT name FROM pragma_table_info('deposits')
    `).all();
    
    const hasCreatorTgId = depositsColumns.some(col => col.name === 'creator_tg_id');
    
    if (!hasCreatorTgId) {
      console.log('‚ö†Ô∏è deposits table missing creator_tg_id column - adding it now...');
      
      db.exec(`
        ALTER TABLE deposits ADD COLUMN creator_tg_id INTEGER;
      `);
      
      // Update existing deposits with creator info
      db.exec(`
        UPDATE deposits 
        SET creator_tg_id = (
          SELECT creator_tg_id FROM tokens WHERE tokens.ca = deposits.ca
        )
        WHERE creator_tg_id IS NULL;
      `);
      
      console.log('‚úÖ Added creator_tg_id to deposits table and updated existing records');
    } else {
      console.log('‚úÖ deposits table has creator_tg_id column');
    }
    
    // 2. Check if payouts table has creator_tg_id column
    const payoutsColumns = db.prepare(`
      SELECT name FROM pragma_table_info('payouts')
    `).all();
    
    const hasPayoutsCreatorTgId = payoutsColumns.some(col => col.name === 'creator_tg_id');
    
    if (!hasPayoutsCreatorTgId) {
      console.log('‚ö†Ô∏è payouts table missing creator_tg_id column - adding it now...');
      
      db.exec(`
        ALTER TABLE payouts ADD COLUMN creator_tg_id INTEGER;
      `);
      
      // Update existing payouts with creator info
      db.exec(`
        UPDATE payouts 
        SET creator_tg_id = (
          SELECT creator_tg_id FROM tokens WHERE tokens.ca = payouts.ca
        )
        WHERE creator_tg_id IS NULL;
      `);
      
      console.log('‚úÖ Added creator_tg_id to payouts table and updated existing records');
    } else {
      console.log('‚úÖ payouts table has creator_tg_id column');
    }
    
    // 3. Migrate existing data to creator_token_pools
    console.log('üîÑ Migrating existing data to creator_token_pools...');
    const tokens = db.prepare(`SELECT ca, creator_tg_id FROM tokens`).all();
    let migratedCount = 0;
    let totalMigratedSOL = 0;
    
    for (const token of tokens) {
      try {
        // Calculate total deposited for this creator/token
        const totalDeposited = db.prepare(`
          SELECT COALESCE(SUM(reward_sol),0) as total 
          FROM deposits 
          WHERE ca=? 
          AND (creator_tg_id=? OR creator_tg_id IS NULL OR creator_tg_id = '')
        `).get(token.ca, token.creator_tg_id);
        
        // Calculate total paid out for this creator/token
        const totalPaid = db.prepare(`
          SELECT COALESCE(SUM(p.sol_amount),0) as total 
          FROM payouts p
          JOIN tokens t ON p.ca = t.ca
          WHERE p.ca=? AND t.creator_tg_id=?
        `).get(token.ca, token.creator_tg_id);
        
        const remaining = Number(totalDeposited?.total || 0) - Number(totalPaid?.total || 0);
        
        if (remaining > 0) {
          // Check if pool already exists
          const existingPool = db.prepare(`
            SELECT sol_amount FROM creator_token_pools 
            WHERE creator_tg_id=? AND token_ca=?
          `).get(token.creator_tg_id, token.ca);
          
          if (!existingPool) {
            db.prepare(`
              INSERT INTO creator_token_pools 
              (creator_tg_id, token_ca, sol_amount, last_updated)
              VALUES (?, ?, ?, ?)
            `).run(token.creator_tg_id, token.ca, remaining, Date.now());
            
            migratedCount++;
            totalMigratedSOL += remaining;
            console.log(`   Migrated ${remaining.toFixed(4)} SOL to creator ${token.creator_tg_id} for token ${token.ca.slice(0, 8)}...`);
          }
        }
      } catch (err) {
        console.log(`   ‚ö†Ô∏è Error migrating token ${token.ca.slice(0, 8)}...: ${err.message}`);
      }
    }
    
    console.log(`‚úÖ Migration completed: ${migratedCount} creator pools updated, total ${totalMigratedSOL.toFixed(4)} SOL migrated`);
    
    // 4. Create indexes for better performance
    console.log('‚ö° Creating performance indexes...');
    
    const indexes = [
      'CREATE INDEX IF NOT EXISTS idx_deposits_ca_creator ON deposits(ca, creator_tg_id)',
      'CREATE INDEX IF NOT EXISTS idx_payouts_ca_creator ON payouts(ca, creator_tg_id)',
      'CREATE INDEX IF NOT EXISTS idx_creator_pools_creator_token ON creator_token_pools(creator_tg_id, token_ca)',
      'CREATE INDEX IF NOT EXISTS idx_creator_payouts_creator_token ON creator_payouts(creator_tg_id, token_ca)',
      'CREATE INDEX IF NOT EXISTS idx_holders_ca_wallet ON holders(ca, wallet)',
      'CREATE INDEX IF NOT EXISTS idx_tokens_creator ON tokens(creator_tg_id)',
      'CREATE INDEX IF NOT EXISTS idx_token_meta_ca ON token_meta(ca)'
    ];
    
    for (const indexSql of indexes) {
      try {
        db.exec(indexSql);
      } catch (e) {
        // Ignore duplicate index errors
      }
    }
    
    console.log('‚úÖ Performance indexes created');
    
  } catch (error) {
    console.log('‚ö†Ô∏è Auto-migration error:', error.message);
    console.log('üí° Continuing bot startup...');
  }
}

/* =========================
   HELPER FUNCTIONS
========================= */
const now = () => Date.now();

async function withRetry(fn, context = '', retries = MAX_RETRIES) {
  for (let i = 0; i < retries; i++) {
    try {
      return await fn();
    } catch (error) {
      console.log(`üîÑ Retry ${i + 1}/${retries} for ${context}:`, error.message);
      if (i === retries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * (i + 1)));
    }
  }
}

function isAdmin(ctx) {
  return ADMIN_IDS.includes(String(ctx.from?.id || ''));
}

function isValidPubkey(s) {
  try { new PublicKey((s || '').trim()); return true; } catch { return false; }
}

function extractFirstPubkey(text) {
  const t = (text || '').trim();
  if (!t) return null;
  const parts = t.split(/\s+/g).filter(Boolean);
  for (const p of parts) if (isValidPubkey(p)) return p;
  const m = t.match(/[1-9A-HJ-NP-Za-km-z]{32,60}/g);
  if (m) for (const cand of m) if (isValidPubkey(cand)) return cand;
  return null;
}

function extractSignatureFromText(text) {
  const t = (text || '').trim();
  const m = t.match(/solscan\.io\/tx\/([A-Za-z0-9]+)/i);
  if (m?.[1]) return m[1];
  if (/^[A-Za-z0-9]{50,120}$/.test(t)) return t;
  return null;
}

function fmtSol(x) {
  return Number(x || 0).toFixed(4);
}

function pumpfunLink(tokenCA) { return `https://pump.fun/${tokenCA}`; }
function dexscreenerTokenLink(tokenCA) { return `https://dexscreener.com/solana/${tokenCA}`; }

function dbGetSetting(k, fallback = null) {
  const r = db.prepare(`SELECT v FROM settings WHERE k=?`).get(k);
  return r?.v ?? fallback;
}

function dbSetSetting(k, v) {
  db.prepare(`INSERT INTO settings (k,v) VALUES (?,?) ON CONFLICT(k) DO UPDATE SET v=excluded.v`)
    .run(k, String(v));
}

function getActiveGroups() {
  return db.prepare(`SELECT chat_id FROM groups WHERE active=1`).all().map(r => String(r.chat_id));
}

function disableGroup(chatId, reason) {
  db.prepare(`UPDATE groups SET active=0, last_error=? WHERE chat_id=?`).run(String(reason || ''), String(chatId));
}

async function safeAnswerCb(ctx) { 
  try { 
    await ctx.answerCbQuery(); 
  } catch (e) {
    console.log('‚ùå Error answering callback:', e.message);
  }
}

function tgErrSummary(e) {
  const code = e?.code;
  const desc = e?.description;
  const msg = e?.message || '';
  return `code=${code || 'n/a'} desc=${desc || 'n/a'} msg=${msg || 'n/a'}`;
}

// Format Market Cap function - FIXED!
function formatMc(mc) {
  const x = Number(mc || 0);
  if (!x) return 'N/A';
  if (x >= 1e9) return `${(x / 1e9).toFixed(2)}B`;
  if (x >= 1e6) return `${(x / 1e6).toFixed(2)}M`;
  if (x >= 1e3) return `${(x / 1e3).toFixed(2)}K`;
  return `${x.toFixed(0)}`;
}

/* =========================
   DM NOTIFICATION FUNCTIONS
========================= */
async function sendPayoutDM(holderTgId, tokenCA, payoutAmount, wallet, signature) {
  try {
    const meta = getMeta(tokenCA);
    const tokenName = meta?.display_name || meta?.name || tokenCA.slice(0, 8);
    
    const dmText = `üéâ WHITEMEME REWARD PAYOUT! üéâ

üí∞ You received: ${fmtSol(payoutAmount)} SOL
üìä Token: ${tokenName}
üëõ Your wallet: ${wallet.slice(0, 8)}...${wallet.slice(-4)}
üìÖ Payout date: ${new Date().toLocaleDateString()}
üîó Transaction: ${signature.slice(0, 16)}...

‚úÖ Thank you for holding!
‚è∞ Keep holding for more rewards! üöÄ`;

    await bot.telegram.sendMessage(holderTgId, dmText);
    console.log(`üì® Payout DM sent to ${holderTgId}: ${fmtSol(payoutAmount)} SOL`);
    return true;
  } catch (error) {
    console.log(`‚ùå Failed to send payout DM to ${holderTgId}:`, error.message);
    return false;
  }
}

async function sendRegistrationDM(holderTgId, tokenCA, wallet, balance, supplyUi) {
  try {
    const meta = getMeta(tokenCA);
    const tokenName = meta?.display_name || meta?.name || tokenCA.slice(0, 8);
    const tokenSymbol = meta?.display_symbol || meta?.symbol || 'N/A';
    
    const holderPct = supplyUi > 0 ? (balance / supplyUi * 100).toFixed(6) : '0';
    const requiredPct = (MIN_HOLDER_PCT * 100).toFixed(4);
    
    const dmText = `‚úÖ WHITEMEME HOLDER REGISTERED!

üìä Token: ${tokenName} #${tokenSymbol}
üëõ Your wallet: ${wallet.slice(0, 8)}...${wallet.slice(-4)}
üìÖ Registered: ${new Date().toLocaleDateString()}
üîç Your balance: ${balance.toFixed(4)} tokens

üìà Eligibility Status:
‚úì Minimum holding: ${requiredPct}% ‚úÖ (you have ${holderPct}%)
‚è∞ Hold time: 0/${MIN_HOLD_HOURS} hours
üí∞ Estimated daily reward: ~${fmtSol(balance / supplyUi * 100)} SOL

‚úÖ You will receive automatic payouts!`;

    await bot.telegram.sendMessage(holderTgId, dmText);
    console.log(`üì® Registration DM sent to ${holderTgId} for ${tokenName}`);
    return true;
  } catch (error) {
    console.log(`‚ùå Failed to send registration DM to ${holderTgId}:`, error.message);
    return false;
  }
}

async function sendEligibilityDM(holderTgId, tokenCA, holdHours) {
  try {
    const meta = getMeta(tokenCA);
    const tokenName = meta?.display_name || meta?.name || tokenCA.slice(0, 8);
    const tokenSymbol = meta?.display_symbol || meta?.symbol || 'N/A';
    
    const dmText = `üìä WHITEMEME ELIGIBILITY UPDATE

üéØ Token: ${tokenName} #${tokenSymbol}
‚úÖ You are NOW ELIGIBLE for rewards!
‚è∞ Hold time: ${holdHours.toFixed(1)}/${MIN_HOLD_HOURS} hours ‚úÖ
üìä Your share: Calculated based on your holdings
üí∞ Next payout: Today 20:00 UTC

üéâ Congratulations! Keep holding for rewards!`;

    await bot.telegram.sendMessage(holderTgId, dmText);
    console.log(`üì® Eligibility DM sent to ${holderTgId} for ${tokenName}`);
    return true;
  } catch (error) {
    console.log(`‚ùå Failed to send eligibility DM to ${holderTgId}:`, error.message);
    return false;
  }
}

/* =========================
   SOLANA HELPER FUNCTIONS
========================= */
async function getMintSupplyAndDecimals(mint) {
  return await withRetry(async () => {
    const pk = new PublicKey(mint);
    const supply = await connection.getTokenSupply(pk, 'confirmed');
    const decimals = Number(supply?.value?.decimals ?? 0);
    const amount = Number(supply?.value?.amount ?? 0);
    const uiAmount = Number(supply?.value?.uiAmount ?? 0);
    return { decimals, rawAmount: amount, uiAmount };
  }, 'getMintSupplyAndDecimals');
}

async function getWalletTokenBalanceUi(wallet, mint) {
  return await withRetry(async () => {
    const owner = new PublicKey(wallet);
    const m = new PublicKey(mint);
    const res = await connection.getParsedTokenAccountsByOwner(owner, { mint: m }, 'confirmed');
    let total = 0;
    for (const acc of res.value || []) {
      const ui = acc.account?.data?.parsed?.info?.tokenAmount?.uiAmount || 0;
      total += Number(ui || 0);
    }
    return total;
  }, 'getWalletTokenBalanceUi');
}

/* =========================
   CREATOR POOL FUNCTIONS (NEUE FUNKTIONEN)
========================= */
function getCreatorTokenPool(creatorId, tokenCA) {
  const row = db.prepare(`
    SELECT sol_amount FROM creator_token_pools 
    WHERE creator_tg_id=? AND token_ca=?
  `).get(creatorId, tokenCA);
  return Number(row?.sol_amount || 0);
}

function getCreatorTotalPool(creatorId) {
  const rows = db.prepare(`
    SELECT sol_amount FROM creator_token_pools 
    WHERE creator_tg_id=?
  `).all(creatorId);
  
  let total = 0;
  rows.forEach(row => total += Number(row.sol_amount || 0));
  return total;
}

function updateCreatorTokenPool(creatorId, tokenCA, amount) {
  db.prepare(`
    INSERT INTO creator_token_pools (creator_tg_id, token_ca, sol_amount, last_updated)
    VALUES (?, ?, ?, ?)
    ON CONFLICT(creator_tg_id, token_ca) DO UPDATE SET
      sol_amount = sol_amount + excluded.sol_amount,
      last_updated = excluded.last_updated
  `).run(creatorId, tokenCA, amount, now());
}

function getCreatorTokenStats(creatorId, tokenCA) {
  const pool = getCreatorTokenPool(creatorId, tokenCA);
  const totalDeposited = db.prepare(`
    SELECT COALESCE(SUM(reward_sol),0) as total 
    FROM deposits 
    WHERE ca=? AND creator_tg_id=?
  `).get(tokenCA, creatorId);
  
  const totalPaid = db.prepare(`
    SELECT COALESCE(SUM(sol_amount),0) as total 
    FROM creator_payouts 
    WHERE creator_tg_id=? AND token_ca=?
  `).get(creatorId, tokenCA);
  
  return {
    pool: Number(pool || 0),
    totalDeposited: Number(totalDeposited?.total || 0),
    totalPaid: Number(totalPaid?.total || 0)
  };
}

/* =========================
   PAYOUT HELPER FUNCTIONS (AKTUALISIERT)
========================= */
function getPayoutEligibility(tokenCA, wallet, balance) {
  const holder = db.prepare(`SELECT registered_at, tg_id FROM holders WHERE ca=? AND wallet=?`).get(tokenCA, wallet);
  if (!holder) return { eligible: false, reason: 'not_registered' };
  
  const registeredAt = Number(holder.registered_at || 0);
  const holdHours = (now() - registeredAt) / (1000 * 60 * 60);
  
  if (holdHours < MIN_HOLD_HOURS) {
    return { 
      eligible: false, 
      reason: 'hold_time', 
      hours: holdHours,
      required: MIN_HOLD_HOURS,
      tg_id: holder.tg_id
    };
  }
  
  const token = getToken(tokenCA);
  if (!token || token.status !== 'ACTIVE') {
    return { eligible: false, reason: 'token_inactive', tg_id: holder.tg_id };
  }
  
  return { eligible: true, holdHours, tg_id: holder.tg_id };
}

async function calculatePayoutsForToken(tokenCA) {
  // WICHTIG: Hole nur den Pool vom jeweiligen Creator
  const token = getToken(tokenCA);
  if (!token) {
    return { totalPayout: 0, recipients: [], message: 'Token not found' };
  }
  
  const creatorId = token.creator_tg_id;
  const creatorPool = getCreatorTokenPool(creatorId, tokenCA);
  
  // Nur den Creator-Pool verwenden, nicht den Gesamtpool
  const pool = creatorPool;
  
  if (pool < MIN_PAYOUT_SOL) {
    return { 
      totalPayout: 0, 
      recipients: [], 
      message: `Creator pool too small: ${fmtSol(pool)} SOL < ${fmtSol(MIN_PAYOUT_SOL)} SOL minimum` 
    };
  }
  
  const holders = db.prepare(`
    SELECT h.wallet, h.registered_at, h.tg_id
    FROM holders h 
    WHERE h.ca=? 
    ORDER BY h.registered_at ASC
    LIMIT ${MAX_PAYOUT_RECIPIENTS}
  `).all(tokenCA);
  
  if (!holders.length) {
    return { totalPayout: 0, recipients: [], message: 'No holders registered' };
  }
  
  let supplyUi = 0;
  try {
    const supply = await getMintSupplyAndDecimals(tokenCA);
    supplyUi = Number(supply.uiAmount || 0);
    console.log(`‚úÖ Token supply for ${tokenCA}: ${supplyUi}`);
  } catch (e) {
    console.log(`‚ùå Error fetching supply for ${tokenCA}:`, e.message);
    return { totalPayout: 0, recipients: [], message: `Token supply unknown: ${e.message}` };
  }
  
  if (supplyUi <= 0) {
    return { totalPayout: 0, recipients: [], message: 'Token supply unknown or zero' };
  }
  
  const eligibleRecipients = [];
  let totalWeight = 0;
  
  for (const holder of holders) {
    try {
      const balance = await getWalletTokenBalanceUi(holder.wallet, tokenCA);
      
      if (balance <= 0) continue;
      
      const holderPct = balance / supplyUi;
      if (holderPct < MIN_HOLDER_PCT) continue;
      
      const eligibility = getPayoutEligibility(tokenCA, holder.wallet, balance);
      
      if (eligibility.eligible) {
        const holderWeight = balance / supplyUi;
        eligibleRecipients.push({
          wallet: holder.wallet,
          balance,
          weight: holderWeight,
          holdHours: eligibility.holdHours,
          holderPct: holderPct * 100,
          tg_id: holder.tg_id
        });
        totalWeight += holderWeight;
      }
    } catch (e) {
      console.log(`‚ùå Error checking holder ${holder.wallet}:`, e.message);
    }
  }
  
  if (!eligibleRecipients.length) {
    return { totalPayout: 0, recipients: [], message: 'No eligible holders' };
  }
  
  const dailyPayoutAmount = pool * DAILY_PAYOUT_PCT;
  const actualPayoutAmount = Math.min(dailyPayoutAmount, pool);
  
  const payouts = [];
  let totalToPay = 0;
  let recipientsCount = 0;
  
  for (const recipient of eligibleRecipients) {
    if (recipientsCount >= MAX_PAYOUTS_PER_ROUND) break;
    
    const share = recipient.weight / totalWeight;
    const payoutAmount = actualPayoutAmount * share;
    
    if (payoutAmount >= MIN_PAYOUT_SOL) {
      payouts.push({
        wallet: recipient.wallet,
        amount: payoutAmount,
        share: share * 100,
        balance: recipient.balance,
        holdHours: recipient.holdHours,
        holderPct: recipient.holderPct,
        tg_id: recipient.tg_id
      });
      totalToPay += payoutAmount;
      recipientsCount++;
    }
  }
  
  return {
    totalPayout: totalToPay,
    recipients: payouts,
    pool,
    supplyUi,
    message: `Calculated ${payouts.length} payouts totaling ${fmtSol(totalToPay)} SOL`
  };
}

async function executePayoutsForToken(tokenCA) {
  const calculation = await calculatePayoutsForToken(tokenCA);
  
  if (calculation.totalPayout <= 0 || !calculation.recipients.length) {
    return {
      success: false,
      message: calculation.message,
      paid: 0,
      recipients: 0,
      transactions: []
    };
  }
  
  const payerBalance = await connection.getBalance(payer.publicKey);
  const requiredBalance = Math.ceil(calculation.totalPayout * LAMPORTS_PER_SOL + PAYOUT_WALLET_BUFFER_LAMPORTS);
  
  if (payerBalance < requiredBalance) {
    return {
      success: false,
      message: `Insufficient balance in payout wallet: ${fmtSol(payerBalance / LAMPORTS_PER_SOL)} SOL < ${fmtSol(requiredBalance / LAMPORTS_PER_SOL)} SOL required`,
      paid: 0,
      recipients: 0,
      transactions: []
    };
  }
  
  const transactions = [];
  let totalPaid = 0;
  let successfulRecipients = 0;
  const token = getToken(tokenCA);
  const creatorId = token.creator_tg_id;
  
  for (const payout of calculation.recipients) {
    try {
      const lamports = Math.floor(payout.amount * LAMPORTS_PER_SOL);
      if (lamports <= 0) continue;
      
      const to = new PublicKey(payout.wallet);
      const tx = new Transaction().add(
        SystemProgram.transfer({ 
          fromPubkey: payer.publicKey, 
          toPubkey: to, 
          lamports 
        })
      );
      
      const sig = await sendAndConfirmTransaction(connection, tx, [payer], { 
        commitment: 'confirmed',
        skipPreflight: false,
        preflightCommitment: 'confirmed'
      });
      
      // Save payout to database
      db.prepare(`
        INSERT INTO payouts (payout_sig, ca, to_wallet, sol_amount, created_at, creator_tg_id)
        VALUES (?, ?, ?, ?, ?, ?)
      `).run(sig, tokenCA, payout.wallet, payout.amount, now(), creatorId);
      
      // Save to creator_payouts table for tracking
      db.prepare(`
        INSERT INTO creator_payouts (creator_tg_id, token_ca, holder_wallet, sol_amount, paid_at)
        VALUES (?, ?, ?, ?, ?)
      `).run(creatorId, tokenCA, payout.wallet, payout.amount, now());
      
      // Update holder stats
      db.prepare(`
        UPDATE holders 
        SET total_paid = total_paid + ?, last_paid_at = ?
        WHERE ca=? AND wallet=?
      `).run(payout.amount, now(), tokenCA, payout.wallet);
      
      // WICHTIG: Creator-Pool reduzieren (nur dieser Creator!)
      db.prepare(`
        UPDATE creator_token_pools 
        SET sol_amount = sol_amount - ?, last_updated = ?
        WHERE creator_tg_id=? AND token_ca=?
      `).run(payout.amount, now(), creatorId, tokenCA);
      
      // Send DM notification to holder
      if (payout.tg_id) {
        await sendPayoutDM(payout.tg_id, tokenCA, payout.amount, payout.wallet, sig);
      }
      
      transactions.push({
        wallet: payout.wallet,
        amount: payout.amount,
        signature: sig,
        tg_id: payout.tg_id,
        success: true
      });
      
      totalPaid += payout.amount;
      successfulRecipients++;
      
      console.log(`‚úÖ Payout to ${payout.wallet.slice(0, 8)}...: ${fmtSol(payout.amount)} SOL (from creator ${creatorId} pool)`);
      
      await new Promise(resolve => setTimeout(resolve, TX_DELAY_MS));
      
    } catch (error) {
      console.log(`‚ùå Payout failed to ${payout.wallet.slice(0, 8)}...:`, error.message);
      transactions.push({
        wallet: payout.wallet,
        amount: payout.amount,
        error: error.message,
        success: false
      });
    }
  }
  
  return {
    success: successfulRecipients > 0,
    message: `Executed ${successfulRecipients} payouts totaling ${fmtSol(totalPaid)} SOL (from creator ${creatorId} pool)`,
    paid: totalPaid,
    recipients: successfulRecipients,
    transactions,
    calculation
  };
}

async function manualPayoutAllTokens() {
  const activeTokens = db.prepare(`
    SELECT t.ca, t.creator_tg_id,
           COALESCE(tm.display_name, tm.name) as name,
           COALESCE(tm.display_symbol, tm.symbol) as symbol
    FROM tokens t
    LEFT JOIN token_meta tm ON tm.ca=t.ca
    WHERE t.status='ACTIVE'
  `).all();
  
  if (!activeTokens.length) {
    return { success: false, message: 'No active tokens found' };
  }
  
  const results = [];
  let totalPaidAll = 0;
  let totalRecipientsAll = 0;
  
  for (const token of activeTokens) {
    console.log(`üí∞ Processing payouts for token: ${token.name || token.ca} (creator: ${token.creator_tg_id})`);
    
    // Check if creator has pool for this token
    const creatorPool = getCreatorTokenPool(token.creator_tg_id, token.ca);
    if (creatorPool < MIN_PAYOUT_SOL) {
      console.log(`‚ö†Ô∏è Skipping ${token.ca}: Creator pool too small (${fmtSol(creatorPool)} SOL)`);
      continue;
    }
    
    const result = await executePayoutsForToken(token.ca);
    
    results.push({
      tokenCA: token.ca,
      tokenName: token.name || 'Unknown',
      tokenSymbol: token.symbol || 'N/A',
      creatorId: token.creator_tg_id,
      ...result
    });
    
    totalPaidAll += result.paid || 0;
    totalRecipientsAll += result.recipients || 0;
    
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
  
  return {
    success: totalPaidAll > 0,
    message: `Manual payout completed: ${totalRecipientsAll} recipients paid ${fmtSol(totalPaidAll)} SOL across ${results.length} tokens`,
    totalPaid: totalPaidAll,
    totalRecipients: totalRecipientsAll,
    results
  };
}

/* =========================
   BONDED POSTING & MILESTONE SYSTEM
========================= */
async function checkAndPostMilestones() {
  const activeTokens = db.prepare(`
    SELECT t.ca, tm.base_mc, tm.last_mc, tm.last_x_posted, tm.bonded_posted,
           COALESCE(tm.display_name, tm.name) as name,
           COALESCE(tm.display_symbol, tm.symbol) as symbol
    FROM tokens t
    LEFT JOIN token_meta tm ON tm.ca=t.ca
    WHERE t.status='ACTIVE' 
      AND tm.base_mc > 0 
      AND tm.last_mc > 0
  `).all();

  for (const token of activeTokens) {
    const currentMC = Number(token.last_mc || 0);
    const baseMC = Number(token.base_mc || 0);
    
    if (baseMC <= 0 || currentMC <= 0) continue;
    
    const multiplier = currentMC / baseMC;
    let milestone = 0;
    
    if (multiplier >= 10 && (!token.last_x_posted || token.last_x_posted < 10)) {
      milestone = 10;
    } else if (multiplier >= 5 && (!token.last_x_posted || token.last_x_posted < 5)) {
      milestone = 5;
    } else if (multiplier >= 2 && (!token.last_x_posted || token.last_x_posted < 2)) {
      milestone = 2;
    }
    
    if (milestone > 0) {
      db.prepare(`UPDATE token_meta SET last_x_posted=? WHERE ca=?`).run(milestone, token.ca);
      
      const isPumpFun = String(token.ca).toLowerCase().endsWith('pump');
      const meta = getMeta(token.ca);
      const isBonded = meta?.on_dex_at_reg === 1 && isPumpFun;
      
      await postMilestone(token.ca, milestone, isBonded);
      
      console.log(`üìà ${isBonded ? 'Bonded' : 'Milestone'} Post: ${token.name} reached ${milestone}x`);
      
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
}

async function postMilestone(tokenCA, milestone, isBonded = false) {
  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const token = getToken(tokenCA);
  const creatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  const displayName = meta?.display_name || meta?.name || 'Token';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  const emojiMap = { 2: 'üí∞', 5: 'üöÄ', 10: 'üíé' };
  const emoji = emojiMap[milestone] || 'üéâ';
  const emojiString = emoji.repeat(milestone);
  
  let caption = '';
  
  if (isBonded) {
    caption = `üéóÔ∏è BONDED POSTING üöÄ

ü™ô Token: ${displayName} #${displaySymbol}
üéØ Status: BONDED TO DEX
üèÜ Achievement: ${milestone}X FROM BOND!

Token successfully bonded and already ${milestone}X!
From Pump.fun to DEX success!

üíé Market Cap: ${formatMc(Number(meta?.last_mc || 0))}
üí∞ Creator Pool: ${fmtSol(creatorPool)} SOL

‚úÖ Bonded token - Fully launched!
‚è∞ Holders earning rewards

${emojiString}`;
  } else {
    caption = `üìà MILESTONE UPDATE!

ü™ô Token: ${displayName} #${displaySymbol}
üèÜ Achievement: ${milestone}X FROM LAUNCH!

Token has ${milestone}X'd from launch price! 
Great momentum building!

üíé Market Cap: ${formatMc(Number(meta?.last_mc || 0))}
üí∞ Creator Pool: ${fmtSol(creatorPool)} SOL

‚úÖ Holders earning automatic rewards
‚è∞ Minimum hold: ${MIN_HOLD_HOURS} hours

${emojiString}`;
  }

  try {
    const me = await bot.telegram.getMe();
    
    let buttons;
    const isPump = String(tokenCA).toLowerCase().endsWith('pump');
    if (isPump) {
      buttons = Markup.inlineKeyboard([
        [
          Markup.button.url('üöÄ Pump.fun', meta?.pump_url || pumpfunLink(tokenCA)),
          Markup.button.url('üìä Chart', meta?.dex_url || dexscreenerTokenLink(tokenCA)),
        ],
        [Markup.button.url('ü§ñ Open WhiteMeme Bot', `https://t.me/${me.username}`)],
      ]);
    } else {
      buttons = Markup.inlineKeyboard([
        [
          Markup.button.url('üìä Chart', meta?.dex_url || dexscreenerTokenLink(tokenCA)),
        ],
        [Markup.button.url('ü§ñ Open WhiteMeme Bot', `https://t.me/${me.username}`)],
      ]);
    }

    const img = meta?.logo_url || null;

    if (img) {
      broadcastToChannelAndGroups('sendPhoto', [img, { 
        caption, 
        reply_markup: buttons.reply_markup,
        parse_mode: 'Markdown'
      }], `(${isBonded ? 'bonded' : 'milestone'} ${milestone}x ${tokenCA.slice(0, 6)}...)`);
    } else {
      broadcastToChannelAndGroups('sendMessage', [caption, { 
        reply_markup: buttons.reply_markup,
        parse_mode: 'Markdown'
      }], `(${isBonded ? 'bonded' : 'milestone'} ${milestone}x ${tokenCA.slice(0, 6)}...)`);
    }

    console.log(`‚úÖ ${isBonded ? 'Bonded' : 'Milestone'} post queued for ${milestone}x: ${tokenCA}`);

  } catch (error) {
    console.log(`‚ùå Error creating ${isBonded ? 'bonded' : 'milestone'} post: ${error.message}`);
  }
}

function startMilestoneChecker() {
  console.log('üìà Starting Milestone Checker...');
  
  setInterval(async () => {
    try {
      const activeTokens = db.prepare(`
        SELECT ca FROM tokens WHERE status='ACTIVE'
      `).all();
      
      for (const token of activeTokens) {
        try {
          const pair = await fetchDexPair(token.ca);
          if (pair) {
            const mc = pairMarketCap(pair);
            if (mc > 0) {
              db.prepare(`UPDATE token_meta SET last_mc=?, last_checked_at=? WHERE ca=?`)
                .run(mc, now(), token.ca);
              
              const meta = getMeta(token.ca);
              if (!meta?.base_mc || Number(meta.base_mc) <= 0) {
                db.prepare(`UPDATE token_meta SET base_mc=? WHERE ca=?`).run(mc, token.ca);
              }
            }
          }
        } catch (e) {
          // Silent fail for individual tokens
        }
        
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      await checkAndPostMilestones();
      
    } catch (error) {
      console.log('‚ùå Milestone checker error:', error.message);
    }
  }, META_REFRESH_MS);
}

/* =========================
   MONOSPACE FORMATTING
========================= */
function monospace(text) {
  return `\`${text}\``;
}

/* =========================
   CHAT CLEANUP
========================= */
async function cleanupPreviousMessage(ctx) {
  try {
    if (ctx.message && ctx.message.message_id) {
      await ctx.deleteMessage();
    }
  } catch (e) {}
}

async function cleanupAfterDelay(ctx, delayMs = 3000) {
  setTimeout(async () => {
    try {
      await ctx.deleteMessage();
    } catch (e) {}
  }, delayMs);
}

async function safeEditOrReply(ctx, text, keyboard = null, cleanupDelay = 0) {
  if (ctx.updateType === 'callback_query') {
    try {
      const msg = await ctx.editMessageText(text, keyboard ? { 
        reply_markup: keyboard.reply_markup,
        parse_mode: 'Markdown'
      } : { parse_mode: 'Markdown' });
      
      if (cleanupDelay > 0 && !text.includes('üé≠ WELCOME') && !text.includes('üë®‚Äçüé® Creator Panel') && !text.includes('üë• Holder Panel') && !text.includes('‚ö° Admin Panel')) {
        cleanupAfterDelay(ctx, cleanupDelay);
      }
      return msg;
    } catch (e) {
      const msg = await ctx.reply(text, keyboard ? { 
        reply_markup: keyboard.reply_markup,
        parse_mode: 'Markdown'
      } : { parse_mode: 'Markdown' });
      
      if (cleanupDelay > 0) {
        cleanupAfterDelay(ctx, cleanupDelay);
      }
      return msg;
    }
  }
  
  const msg = await ctx.reply(text, keyboard ? { 
    reply_markup: keyboard.reply_markup,
    parse_mode: 'Markdown'
  } : { parse_mode: 'Markdown' });
  
  if (cleanupDelay > 0) {
    cleanupAfterDelay(ctx, cleanupDelay);
  }
  return msg;
}

/* =========================
   BROADCAST QUEUE
========================= */
const broadcastQueue = [];
let broadcastWorkerRunning = false;

function enqueueBroadcast(method, chatId, payload, tag = '') {
  broadcastQueue.push({ method, chatId: String(chatId), payload, tries: 0, tag });
}

async function startBroadcastWorker() {
  if (broadcastWorkerRunning) return;
  
  console.log('üì¢ STARTING Broadcast Worker...');
  broadcastWorkerRunning = true;

  while (broadcastWorkerRunning) {
    const job = broadcastQueue.shift();
    if (!job) { 
      await new Promise(r => setTimeout(r, 100)); 
      continue; 
    }

    console.log(`üì¢ Processing: ${job.method} -> ${job.chatId} (Queue: ${broadcastQueue.length})`);
    
    try {
      await new Promise(r => setTimeout(r, BROADCAST_DELAY_MS));
      await bot.telegram[job.method](job.chatId, ...job.payload);
      console.log(`üì¢ ‚úÖ Success: ${job.method} -> ${job.chatId}`);
    } catch (e) {
      const summary = tgErrSummary(e);
      console.log(`üì¢ ‚ùå Error: ${job.method} -> ${job.chatId}: ${summary}`);

      const code = e?.code;
      const desc = String(e?.description || '');
      const hard =
        code === 403 ||
        (code === 400 && /chat not found|bot was kicked|forbidden|not enough rights/i.test(desc));

      if (hard && String(job.chatId).startsWith('-')) {
        disableGroup(job.chatId, `auto-disabled: ${desc || summary}`);
        console.log(`üì¢ Group disabled: ${job.chatId} Reason: ${desc || summary}`);
      }

      if (job.method === 'sendPhoto') {
        try {
          const photoArgs = job.payload;
          const opts = photoArgs?.[1] || {};
          const caption = String(opts.caption || '');
          const reply_markup = opts.reply_markup;
          enqueueBroadcast('sendMessage', job.chatId, [caption, { reply_markup, parse_mode: 'Markdown' }], '(fallback from photo)');
          continue;
        } catch {}
      }

      if (job.tries < 3 && /Too Many Requests|timeout|ECONNRESET|ETELEGRAM|EFATAL/i.test(String(e?.message || desc || ''))) {
        job.tries += 1;
        broadcastQueue.push(job);
        await new Promise(r => setTimeout(r, 1200));
      }
    }
  }
}

function broadcastToChannelAndGroups(method, payload, tag = '') {
  const targets = [String(CHANNEL_ID), ...getActiveGroups()];
  console.log(`üì¢ BROADCAST: ${targets.length} targets, Method=${method}, Tag=${tag}`);
  for (const chatId of targets) enqueueBroadcast(method, chatId, payload, tag);
}

/* =========================
   TOKEN DATA
========================= */
const metaCache = new Map();

async function fetchDexPair(tokenCA) {
  return await withRetry(async () => {
    const url = `https://api.dexscreener.com/latest/dex/tokens/${tokenCA}`;
    const res = await axios.get(url, { timeout: HTTP_TIMEOUT_MS });
    return res.data?.pairs?.[0] || null;
  }, 'fetchDexPair');
}

function pairMarketCap(pair) {
  const mc = Number(pair?.fdv ?? pair?.marketCap ?? 0);
  return Number.isFinite(mc) ? mc : 0;
}
function pairName(pair) { return pair?.baseToken?.name || null; }
function pairSymbol(pair) { return pair?.baseToken?.symbol || null; }
function pairAddress(pair) { return pair?.pairAddress || null; }
function pairLogo(pair) {
  return pair?.baseToken?.logoURI || pair?.info?.imageUrl || pair?.info?.imageUrl || null;
}

/* =========================
   Pump.fun META
========================= */
async function fetchPumpMeta(tokenCA) {
  return await withRetry(async () => {
    const url = pumpfunLink(tokenCA);
    const html = (await axios.get(url, { timeout: HTTP_TIMEOUT_MS })).data;

    const mImg = html.match(/property=["']og:image["'][^>]*content=["']([^"']+)["']/i);
    const img = (mImg?.[1] || '').trim() || null;

    const mTitle = html.match(/property=["']og:title["'][^>]*content=["']([^"']+)["']/i);
    const title = (mTitle?.[1] || '').trim();

    let name = null;
    let symbol = null;

    const mt = title.match(/^(.+?)\s*\((?:\$)?([A-Za-z0-9_]{1,15})\)\s*$/);
    if (mt) {
      name = mt[1]?.trim() || null;
      symbol = mt[2]?.trim() || null;
    } else if (title) {
      name = title.slice(0, 64);
    }

    return { ok: true, name, symbol, img, pump_url: url };
  }, 'fetchPumpMeta');
}

/* =========================
   META UPSERT WITH CACHE
========================= */
function upsertTokenMeta(tokenCA, fields) {
  const pump_url = pumpfunLink(tokenCA);
  const dex_url = dexscreenerTokenLink(tokenCA);

  db.prepare(`
    INSERT INTO token_meta (ca, name, symbol, pump_url, dex_url, pair_address, on_dex_at_reg, logo_url, display_name, display_symbol)
    VALUES (@ca, @name, @symbol, @pump_url, @dex_url, @pair_address, @on_dex_at_reg, @logo_url, @display_name, @display_symbol)
    ON CONFLICT(ca) DO UPDATE SET
      name=COALESCE(excluded.name, token_meta.name),
      symbol=COALESCE(excluded.symbol, token_meta.symbol),
      pump_url=excluded.pump_url,
      dex_url=excluded.dex_url,
      pair_address=COALESCE(excluded.pair_address, token_meta.pair_address),
      on_dex_at_reg=COALESCE(token_meta.on_dex_at_reg, excluded.on_dex_at_reg),
      logo_url=COALESCE(excluded.logo_url, token_meta.logo_url),
      display_name=COALESCE(excluded.display_name, token_meta.display_name),
      display_symbol=COALESCE(excluded.display_symbol, token_meta.display_symbol)
  `).run({
    ca: tokenCA,
    name: fields.name || null,
    symbol: fields.symbol || null,
    pump_url,
    dex_url,
    pair_address: fields.pair_address || null,
    on_dex_at_reg: Number(fields.on_dex_at_reg || 0),
    logo_url: fields.logo_url || null,
    display_name: fields.display_name || null,
    display_symbol: fields.display_symbol || null,
  });

  const result = getMeta(tokenCA);
  metaCache.set(tokenCA, { data: result, timestamp: Date.now() });
  return result;
}

async function refreshMetaPriority(tokenCA) {
  const cached = metaCache.get(tokenCA);
  if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {
    return cached.data;
  }

  const isPump = String(tokenCA).toLowerCase().endsWith('pump');

  let pump = { ok: false }
  let dexPair = null;

  if (isPump) {
    pump = await fetchPumpMeta(tokenCA);
    try { dexPair = await fetchDexPair(tokenCA); } catch {}
  } else {
    try { dexPair = await fetchDexPair(tokenCA); } catch {}
    pump = await fetchPumpMeta(tokenCA);
  }

  const name = (isPump ? (pump.name || null) : (pairName(dexPair) || null)) || pump.name || pairName(dexPair) || null;
  const symbol = (isPump ? (pump.symbol || null) : (pairSymbol(dexPair) || null)) || pump.symbol || pairSymbol(dexPair) || null;

  const logo_url =
    (isPump ? (pump.img || null) : (pairLogo(dexPair) || null)) ||
    pump.img ||
    pairLogo(dexPair) ||
    null;

  const onDexAtReg = dexPair ? 1 : 0;
  const pairAddr = dexPair ? pairAddress(dexPair) : null;

  upsertTokenMeta(tokenCA, { name, symbol, on_dex_at_reg: onDexAtReg, pair_address: pairAddr, logo_url });

  if (dexPair) {
    const mc = pairMarketCap(dexPair);
    if (mc > 0) {
      db.prepare(`UPDATE token_meta SET last_mc=?, last_checked_at=? WHERE ca=?`).run(mc, now(), tokenCA);
    }
  }

  const result = getMeta(tokenCA);
  metaCache.set(tokenCA, { data: result, timestamp: Date.now() });
  return result;
}

/* =========================
   POSTING FUNCTION - UPDATED FORMAT!
========================= */
async function postToChannelAndGroups(tokenCA, extraLine = '') {
  console.log(`üöÄ POST for Token: ${tokenCA}`);
  
  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const token = getToken(tokenCA);
  const creatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  const displayName = meta?.display_name || meta?.name || 'Unknown Token';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  const isPump = String(tokenCA).toLowerCase().endsWith('pump');
  
  // Format: "Token Name (Symbol) - Pump #Symbol"
  const tokenLine = `${displayName} (${displaySymbol}) - Pump #${displaySymbol}`;
  
  const caption = `üé≠ WHITEMEME üöÄ NEW TOKEN LISTED!

ü™ô Token: ${tokenLine}
üíé Market Cap: ${formatMc(Number(meta?.last_mc || 0))}
üèÜ Creator Pool: ${fmtSol(creatorPool)} SOL

üîê CA: ${monospace(tokenCA)}

${extraLine || '‚úÖ Activated (deposit confirmed) üéâ'}

‚úÖ Registered holders can earn rewards!
‚è∞ Minimum hold: ${MIN_HOLD_HOURS} hours
üöÄ Longer hold = More rewards!`;

  try {
    const me = await bot.telegram.getMe();
    
    let buttons;
    if (isPump) {
      buttons = Markup.inlineKeyboard([
        [
          Markup.button.url('üöÄ Pump.fun', meta?.pump_url || pumpfunLink(tokenCA)),
          Markup.button.url('üìä Chart', meta?.dex_url || dexscreenerTokenLink(tokenCA)),
        ],
        [Markup.button.url('ü§ñ Open WhiteMeme Bot', `https://t.me/${me.username}`)],
      ]);
    } else {
      buttons = Markup.inlineKeyboard([
        [
          Markup.button.url('üìä Chart', meta?.dex_url || dexscreenerTokenLink(tokenCA)),
        ],
        [Markup.button.url('ü§ñ Open WhiteMeme Bot', `https://t.me/${me.username}`)],
      ]);
    }

    const img = meta?.logo_url || null;

    if (img) {
      broadcastToChannelAndGroups('sendPhoto', [img, { 
        caption, 
        reply_markup: buttons.reply_markup,
        parse_mode: 'Markdown'
      }], `(listing ${tokenCA.slice(0, 6)}...)`);
    } else {
      broadcastToChannelAndGroups('sendMessage', [caption, { 
        reply_markup: buttons.reply_markup,
        parse_mode: 'Markdown'
      }], `(listing ${tokenCA.slice(0, 6)}...)`);
    }

    console.log(`‚úÖ Listing post queued for Token: ${tokenCA}`);

  } catch (error) {
    console.log(`‚ùå Error creating listing post: ${error.message}`);
  }
}

/* =========================
   AUTO-PAYOUT SCHEDULER (20:00 UTC Daily)
========================= */
function startAutoPayoutScheduler() {
  console.log('‚è∞ Starting Auto-Payout Scheduler (20:00 UTC daily)...');
  
  const scheduleNextPayout = () => {
    const now = new Date();
    const target = new Date(now);
    target.setUTCHours(20, 0, 0, 0);
    
    if (now > target) {
      target.setUTCDate(target.getUTCDate() + 1);
    }
    
    const delay = target.getTime() - now.getTime();
    
    console.log(`‚è∞ Next auto-payout scheduled for: ${target.toUTCString()} (in ${Math.round(delay / 1000 / 60)} minutes)`);
    
    setTimeout(async () => {
      console.log('üí∞ Starting automatic daily payout...');
      try {
        const result = await manualPayoutAllTokens();
        console.log(`‚úÖ Auto-payout completed: ${result.message}`);
        
        const adminMsg = `üí∞ Daily Auto-Payout Executed\n\nStatus: ${result.success ? '‚úÖ SUCCESS' : '‚ö†Ô∏è PARTIAL'}\nMessage: ${result.message}\nTime: ${new Date().toLocaleString()}`;
        for (const adminId of ADMIN_IDS) {
          try {
            await bot.telegram.sendMessage(adminId, adminMsg);
          } catch {}
        }
      } catch (error) {
        console.log('‚ùå Auto-payout failed:', error.message);
      }
      
      scheduleNextPayout();
    }, delay);
  };
  
  scheduleNextPayout();
}

/* =========================
   FEES + DEPOSIT CHECK
========================= */
async function sendFeeTransfer(feeSol) {
  return await withRetry(async () => {
    const lamports = Math.floor(feeSol * LAMPORTS_PER_SOL);
    if (lamports <= 0) return null;

    const sendLamports = Math.max(0, lamports - 10_000);
    if (sendLamports <= 0) return null;

    const to = new PublicKey(FEE_WALLET);
    const tx = new Transaction().add(
      SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: to, lamports: sendLamports })
    );

    const sig = await sendAndConfirmTransaction(connection, tx, [payer], { commitment: 'confirmed' });
    return sig;
  }, 'sendFeeTransfer');
}

async function verifyDepositTx(signature, expectedToWallet) {
  return await withRetry(async () => {
    const parsed = await connection.getParsedTransaction(signature, {
      commitment: 'confirmed',
      maxSupportedTransactionVersion: 0,
    });

    if (!parsed?.meta) return { ok: false, reason: 'tx_not_found' };

    let found = false;
    let fromWallet = null;
    let solAmount = 0;

    const instructions = parsed.transaction.message.instructions || [];
    for (const ix of instructions) {
      if (ix?.program === 'system') {
        const info = ix?.parsed?.info;
        if (info?.destination === expectedToWallet && info?.lamports) {
          found = true;
          fromWallet = info?.source || null;
          solAmount += Number(info.lamports) / LAMPORTS_PER_SOL;
        }
      }
    }

    if (!found) return { ok: false, reason: 'no_transfer_to_reward_wallet' };
    if (solAmount <= 0) return { ok: false, reason: 'zero_amount' };
    return { ok: true, solAmount, fromWallet };
  }, 'verifyDepositTx');
}

/* =========================
   STATE
========================= */
const state = new Map();
const setState = (uid, obj) => state.set(uid, obj);
const getState = (uid) => state.get(uid);
const clearState = (uid) => state.delete(uid);

/* =========================
   CALLBACK KEYS
========================= */
const CB = {
  HOME: 'H',
  HELP: 'HP',
  CRE_HOME: 'CH',
  HOL_HOME: 'HH',
  CRE_REG: 'CR',
  CRE_LIST: 'CL',
  HOL_REG: 'HR',
  HOL_MY: 'HM',
  HOL_REM: 'HD',
  ADM_HOME: 'AH',
  ADM_SUM: 'AS',
  ADM_PAYOUT: 'AP',
  ADM_GROUPS: 'AG',
  ADM_TOKENS: 'AT',
};

function paginateRows(rows, page, pageSize) {
  const p = Math.max(0, Number(page || 0));
  const start = p * pageSize;
  const slice = rows.slice(start, start + pageSize);
  const maxPage = Math.max(0, Math.ceil(rows.length / pageSize) - 1);
  return { page: p, maxPage, slice };
}

/* =========================
   MENUS
========================= */
function homeKeyboard(ctx) {
  const rows = [
    [Markup.button.callback('üë®‚Äçüé® Creator Panel', CB.CRE_HOME)],
    [Markup.button.callback('üë• Holder Panel', CB.HOL_HOME)],
    [
      ...(CHANNEL_LINK ? [Markup.button.url('üì¢ Channel', CHANNEL_LINK)] : []),
      ...(TWITTER_LINK ? [Markup.button.url('ùïè Twitter', TWITTER_LINK)] : []),
    ].filter(Boolean),
    [Markup.button.callback('‚ùì Help', CB.HELP)],
  ];

  if (isAdmin(ctx)) rows.push([Markup.button.callback('‚ö° Admin Panel', CB.ADM_HOME)]);

  return Markup.inlineKeyboard(rows.filter(r => r.length));
}

function creatorHomeKeyboard() {
  return Markup.inlineKeyboard([
    [Markup.button.callback('‚ûï Register Token', CB.CRE_REG)],
    [Markup.button.callback('üóÇÔ∏è My Tokens', `${CB.CRE_LIST}:0`)],
    [Markup.button.callback('üè† Start', CB.HOME)],
  ]);
}

function holderHomeKeyboard() {
  return Markup.inlineKeyboard([
    [Markup.button.callback('‚úÖ Register as Holder', CB.HOL_REG)],
    [Markup.button.callback('üìã My Registrations', `${CB.HOL_MY}:0`)],
    [Markup.button.callback('üóëÔ∏è Remove Registration', CB.HOL_REM)],
    [Markup.button.callback('üè† Start', CB.HOME)],
  ]);
}

function adminHomeKeyboard() {
  return Markup.inlineKeyboard([
    [Markup.button.callback('üìà Global Analytics', CB.ADM_SUM)],
    [Markup.button.callback('üöÄ RUN PAYOUT NOW', CB.ADM_PAYOUT)],
    [Markup.button.callback('ü™ô Manage Tokens', `${CB.ADM_TOKENS}:0`)],
    [Markup.button.callback('üë• Manage Groups', `${CB.ADM_GROUPS}:0`)],
    [Markup.button.callback('üè† Start', CB.HOME)],
  ]);
}

function tokenConfirmKeyboard(tokenCA) {
  return Markup.inlineKeyboard([
    [Markup.button.callback('‚úÖ Confirm Token', `CONF:${tokenCA}`)],
    [Markup.button.callback('‚ùå Cancel', 'CXL')],
  ]);
}

function creatorManageKeyboard(tokenCA) {
  const buttons = [
    [Markup.button.callback('üí∏ Deposit / Check Payment', `DEP:${tokenCA}`)],
    [
      Markup.button.callback('üìä Stats', `CST:${tokenCA}`),
      Markup.button.callback('üìã Report', `REP:${tokenCA}`),
    ],
    [
      Markup.button.callback('üë§ Holder Stats', `CHS:${tokenCA}`),
      Markup.button.callback('üé® Edit Display', `EDN:${tokenCA}`),
    ],
    [Markup.button.callback('üö´ Deactivate', `DEA:${tokenCA}`)],
    [Markup.button.callback('‚¨ÖÔ∏è Back', `${CB.CRE_LIST}:0`)],
  ];
  
  return Markup.inlineKeyboard(buttons);
}

function paymentKeyboard(tokenCA) {
  return Markup.inlineKeyboard([
    [Markup.button.callback('üîé Check Payment', `CHK:${tokenCA}`)],
    [Markup.button.callback('‚¨ÖÔ∏è Back', `MAN:${tokenCA}`)],
  ]);
}

function adminTokenActionsKeyboard(tokenCA, backPage = 0) {
  return Markup.inlineKeyboard([
    [
      Markup.button.callback('üîÑ Repost', `AR:${tokenCA}:${backPage}`),
      Markup.button.callback('üí∏ PAY NOW', `PAYTOKEN:${tokenCA}`),
    ],
    [
      Markup.button.callback('üéóÔ∏è Bonded Posts', `BONDED:${tokenCA}:${backPage}`),
      Markup.button.callback('üßÆ Calc Payout', `CALCPAY:${tokenCA}:${backPage}`),
    ],
    [
      Markup.button.callback('üÜë Reset Alerts', `AX:${tokenCA}:${backPage}`),
      Markup.button.callback('üìà Update MC', `UPDATEMC:${tokenCA}:${backPage}`),
    ],
    [
      Markup.button.callback('‚úÖ Activate', `AA:${tokenCA}:${backPage}`),
      Markup.button.callback('‚≠ï Inactivate', `AI:${tokenCA}:${backPage}`),
    ],
    [Markup.button.callback('üóëÔ∏è Delete', `AD:${tokenCA}:${backPage}`)],
    [Markup.button.callback('‚¨ÖÔ∏è Back', `${CB.ADM_TOKENS}:${backPage}`)],
  ]);
}

/* =========================
   GROUP ACTIVATION
========================= */
function saveGroupChat(ctx) {
  if (ctx.chat?.type !== 'group' && ctx.chat?.type !== 'supergroup') return false;
  db.prepare(`
    INSERT INTO groups (chat_id, title, active, created_at, last_error)
    VALUES (?, ?, 1, ?, NULL)
    ON CONFLICT(chat_id) DO UPDATE SET active=1, title=excluded.title, last_error=NULL
  `).run(String(ctx.chat.id), ctx.chat.title || '', now());
  return true;
}

bot.command('activate', async (ctx) => {
  const ok = saveGroupChat(ctx);
  if (!ok) return ctx.reply('‚ö†Ô∏è Use /activate inside a group.');
  await ctx.reply('‚úÖ Group activated! This group will now receive üé≠ WHITEMEME posts. üöÄ');
  cleanupAfterDelay(ctx, 3000);
});

bot.command('syncgroup', async (ctx) => {
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');
  const ok = saveGroupChat(ctx);
  if (!ok) return ctx.reply('‚ö†Ô∏è Use /syncgroup inside a group.');
  await ctx.reply('‚úÖ Group synced and activated (admin).');
  cleanupAfterDelay(ctx, 3000);
});

bot.command('testbroadcast', async (ctx) => {
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');
  const groups = getActiveGroups();
  const msg = `üì¢ üé≠ WHITEMEME TEST BROADCAST\n\nIf you see this in the channel AND your groups, delivery is working ‚úÖ\nChannel target: ${CHANNEL_ID}\nActive groups: ${groups.length}\n\nTime: ${new Date().toUTCString()} üöÄ`;
  broadcastToChannelAndGroups('sendMessage', [msg], '(testbroadcast)');
  await ctx.reply('‚úÖ Test broadcast queued. Check your channel and group(s).');
  cleanupAfterDelay(ctx, 3000);
});

/* =========================
   ADMIN CONTROLS FOR BONDED POSTING
========================= */
bot.action(/^BONDED:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  const confirmKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback('‚úÖ 2X Post', `BONDEDFORCE:${tokenCA}:2:${backPage}`)],
    [Markup.button.callback('‚úÖ 5X Post', `BONDEDFORCE:${tokenCA}:5:${backPage}`)],
    [Markup.button.callback('‚úÖ 10X Post', `BONDEDFORCE:${tokenCA}:10:${backPage}`)],
    [Markup.button.callback('üîÑ Reset Milestones', `BONDEDRESET:${tokenCA}:${backPage}`)],
    [Markup.button.callback('üîô Back', `${CB.ADM_TOKENS}:${backPage}`)],
  ]);
  
  const meta = getMeta(tokenCA);
  const baseMC = Number(meta?.base_mc || 0);
  const currentMC = Number(meta?.last_mc || 0);
  const bondedPosted = Number(meta?.bonded_posted || 0);
  
  let status = 'No base MC set';
  if (baseMC > 0 && currentMC > 0) {
    const multiplier = (currentMC / baseMC).toFixed(2);
    status = `${multiplier}x from base (${formatMc(currentMC)} / ${formatMc(baseMC)})`;
  }
  
  await ctx.reply(
`üéóÔ∏è Bonded Posting Control

Token: ${meta?.display_name || meta?.name || 'Unknown'}
Current: ${status}
Last posted milestone: ${bondedPosted > 0 ? `${bondedPosted}x` : 'None'}

Force post a milestone or reset:`,
    confirmKeyboard
  );
});

bot.action(/^BONDEDFORCE:(.+):(\d+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');
  
  const tokenCA = ctx.match[1];
  const milestone = Number(ctx.match[2]);
  const backPage = Number(ctx.match[3] || 0);
  
  const isPump = String(tokenCA).toLowerCase().endsWith('pump');
  const meta = getMeta(tokenCA);
  const isBonded = meta?.on_dex_at_reg === 1 && isPump;
  
  db.prepare(`UPDATE token_meta SET bonded_posted=? WHERE ca=?`).run(milestone, tokenCA);
  
  await postMilestone(tokenCA, milestone, isBonded);
  
  await ctx.reply(`‚úÖ Forced ${milestone}x ${isBonded ? 'bonded' : 'milestone'} post for token.`, adminHomeKeyboard());
});

bot.action(/^BONDEDRESET:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  db.prepare(`UPDATE token_meta SET bonded_posted=0, last_x_posted=0 WHERE ca=?`).run(tokenCA);
  
  await ctx.reply(`‚úÖ Bonded milestones reset for token.`, adminHomeKeyboard());
});

bot.action(/^UPDATEMC:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  try {
    const pair = await fetchDexPair(tokenCA);
    if (pair) {
      const mc = pairMarketCap(pair);
      const meta = getMeta(tokenCA);
      
      if (mc > 0) {
        db.prepare(`UPDATE token_meta SET last_mc=?, last_checked_at=? WHERE ca=?`)
          .run(mc, now(), tokenCA);
        
        if (!meta?.base_mc || Number(meta.base_mc) <= 0) {
          db.prepare(`UPDATE token_meta SET base_mc=? WHERE ca=?`).run(mc, tokenCA);
        }
        
        await ctx.reply(`‚úÖ Market Cap updated: ${formatMc(mc)}`, adminHomeKeyboard());
      } else {
        await ctx.reply(`‚ö†Ô∏è No market cap found`, adminHomeKeyboard());
      }
    } else {
      await ctx.reply(`‚ö†Ô∏è No pair data found`, adminHomeKeyboard());
    }
  } catch (error) {
    await ctx.reply(`‚ùå Error: ${error.message}`, adminHomeKeyboard());
  }
});

/* =========================
   START / HOME / HELP
========================= */
async function sendWelcome(ctx) {
  clearState(ctx.from.id);
  
  await cleanupPreviousMessage(ctx);

  if (ctx.chat?.type === 'group' || ctx.chat?.type === 'supergroup') {
    saveGroupChat(ctx);
    return ctx.reply('‚úÖ Group activated! This group will receive üé≠ WHITEMEME posts. üöÄ');
  }

  const text = `üé≠ WELCOME TO WHITEMEME BOT ü§ñ

‚ú® What you can do here:

üë®‚Äçüé® Creators
1) Register your token (any Solana mint CA) ü™ô
2) Confirm the token ‚úÖ
3) Fund the rewards pool (send SOL) üí∞
4) After your deposit is confirmed, the bot posts to the Channel + Active Groups ‚úÖ

üë• Holders
1) Register for a token üìù
2) Add your Solana wallet üëõ
3) Stay eligible by holding long enough ‚è∞

üîí Safety
üëõ No custody. No private keys. You control your wallet.

Tap a panel below to start üëá`;

  await ctx.reply(text, homeKeyboard(ctx));
}

bot.start(async (ctx) => {
  await cleanupPreviousMessage(ctx);
  await sendWelcome(ctx);
});

bot.action(CB.HOME, async (ctx) => { 
  await safeAnswerCb(ctx); 
  await sendWelcome(ctx); 
});

bot.action(CB.HELP, async (ctx) => {
  await safeAnswerCb(ctx);

  let text = `‚ùì HELP & GUIDELINES üìö

üë®‚Äçüé® CREATOR FLOW
1) Creator Panel ‚Üí Register Token (paste mint CA) ü™ô
2) Confirm token ‚úÖ
3) Deposit/Payment ‚Üí Send SOL to the Reward Wallet üí∏
4) Paste Solscan TX link ‚Üí Check Payment üîé
5) After confirmed: bot posts to the Channel + Active Groups üöÄ

üë• HOLDER FLOW
1) Holder Panel ‚Üí Register as Holder üìù
2) Send Token CA ü™ô
3) Send your Solana wallet üëõ

‚úÖ Eligibility rules
- Minimum hold time: ${MIN_HOLD_HOURS} hours ‚è∞
- Minimum holding: ${(MIN_HOLDER_PCT * 100).toFixed(4)}% of total supply ü™ô
- Do NOT sell during holding period üìâ
- The longer you hold, the more rewards you earn! üíé

üë• GROUPS
- In a group: /activate (anyone) or /syncgroup (admin) üîß

üéóÔ∏è BONDED POSTING
- Auto-posts at 2x, 5x, 10x market cap milestones üìàüöÄüíé
- Uses üéóÔ∏è emoji for bonded posts (Pump.fun tokens only)

üí° Tip: You will receive DM notifications for payouts! üì®`;

  if (isAdmin(ctx)) {
    text += `

‚ö° ADMIN SECTION (Your ID: ${ctx.from.id})
- Analytics, manage tokens/groups, repost, reset alerts, run payouts.
- Use /testbroadcast to verify delivery instantly.`;
  }

  await ctx.reply(text);
});

/* =========================
   HOLDER PANEL
========================= */
bot.action(CB.HOL_HOME, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  await safeEditOrReply(ctx, 'üë• Holder Panel', holderHomeKeyboard());
});

bot.action(CB.HOL_REG, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  setState(ctx.from.id, { mode: 'holder_send_token' });
  await ctx.reply(
`‚úÖ Holder Registration üìù

To register for rewards:
1. Send token CA (mint address) ü™ô
2. Send your Solana wallet address üëõ

You must:
‚Ä¢ Hold at least ${(MIN_HOLDER_PCT * 100).toFixed(4)}% of token supply ü™ô
‚Ä¢ Hold for minimum ${MIN_HOLD_HOURS} hours ‚è∞
‚Ä¢ Do NOT sell during holding period üìâ

Send the token CA now:`
  );
});

bot.action(CB.HOL_REM, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  setState(ctx.from.id, { mode: 'holder_remove_token' });
  await ctx.reply(
`üóëÔ∏è Remove Registration

Send the token CA you want to remove registration for:`,
    holderHomeKeyboard()
  );
});

async function renderHolderRegistrations(ctx, page = 0) {
  const uid = ctx.from.id;
  const rows = db.prepare(`
    SELECT h.ca, h.wallet, h.registered_at, h.total_paid,
           COALESCE(tm.display_name, tm.name) as name,
           COALESCE(tm.display_symbol, tm.symbol) as symbol
    FROM holders h
    LEFT JOIN token_meta tm ON tm.ca=h.ca
    WHERE h.tg_id=?
    ORDER BY h.registered_at DESC
  `).all(uid);

  if (!rows.length) {
    return safeEditOrReply(ctx, 'üìã No registrations yet.\n\nRegister for a token to start earning rewards! üöÄ', holderHomeKeyboard());
  }

  const { page: p, maxPage, slice } = paginateRows(rows, page, 5);

  let msg = `üìã My Registrations (${p + 1}/${maxPage + 1})\n\n`;
  slice.forEach((r, idx) => {
    const name = r.name || 'Unknown';
    const symbol = r.symbol ? `$${r.symbol}` : 'N/A';
    const walletShort = r.wallet.slice(0, 8) + '...' + r.wallet.slice(-4);
    const registered = new Date(r.registered_at).toLocaleDateString();
    const holdHours = ((now() - r.registered_at) / (1000 * 60 * 60)).toFixed(1);
    const totalPaid = Number(r.total_paid || 0);
    
    msg += `${idx+1}. ${name} (${symbol})\n`;
    msg += `   Wallet: ${walletShort}\n`;
    msg += `   Registered: ${registered}\n`;
    msg += `   Hold time: ${holdHours}h / ${MIN_HOLD_HOURS}h ‚è∞\n`;
    msg += `   Total earned: ${fmtSol(totalPaid)} SOL üí∞\n\n`;
  });

  const nav = [];
  if (p > 0) nav.push(Markup.button.callback('‚óÄÔ∏è Back', `${CB.HOL_MY}:${p - 1}`));
  if (p < maxPage) nav.push(Markup.button.callback('Next ‚ñ∂Ô∏è', `${CB.HOL_MY}:${p + 1}`));

  const kb = Markup.inlineKeyboard([
    ...(nav.length ? [nav] : []),
    [Markup.button.callback('‚úÖ New Registration', CB.HOL_REG)],
    [Markup.button.callback('üóëÔ∏è Remove Registration', CB.HOL_REM)],
    [Markup.button.callback('üè† Start', CB.HOME)],
  ]);

  await safeEditOrReply(ctx, msg, kb, 0);
}

bot.action(new RegExp(`^${CB.HOL_MY}:(\\d+)$`), async (ctx) => {
  await safeAnswerCb(ctx);
  await renderHolderRegistrations(ctx, Number(ctx.match[1] || 0));
});

/* =========================
   ADMIN PANEL - COMPLETELY FIXED!
========================= */
bot.action(CB.ADM_HOME, async (ctx) => {
  console.log('‚ö° Admin Panel clicked, user ID:', ctx.from.id);
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  await safeEditOrReply(ctx, '‚ö° Admin Panel', adminHomeKeyboard());
});

bot.action(CB.ADM_SUM, async (ctx) => {
  await safeAnswerCb(ctx);
  await showAdminSummary(ctx);
});

bot.action(CB.ADM_PAYOUT, async (ctx) => {
  await safeAnswerCb(ctx);
  await executeAdminPayout(ctx);
});

// Neue Navigation Handler f√ºr Admin Tokens
bot.action(/^ADM_TOKENS_PREV:(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  await renderAdminTokens(ctx, Number(ctx.match[1] || 0));
});

bot.action(/^ADM_TOKENS_NEXT:(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  await renderAdminTokens(ctx, Number(ctx.match[1] || 0));
});

bot.action(new RegExp(`^${CB.ADM_TOKENS}:(\\d+)$`), async (ctx) => {
  console.log('üîç ADM_TOKENS callback received:', ctx.callbackQuery.data);
  await safeAnswerCb(ctx);
  await renderAdminTokens(ctx, Number(ctx.match[1] || 0));
});

bot.action(new RegExp(`^${CB.ADM_GROUPS}:(\\d+)$`), async (ctx) => {
  await safeAnswerCb(ctx);
  await renderAdminGroups(ctx, Number(ctx.match[1] || 0));
});

async function showAdminSummary(ctx) {
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');

  const tokenStats = db.prepare(`
    SELECT 
      COUNT(*) as total,
      SUM(CASE WHEN status='ACTIVE' THEN 1 ELSE 0 END) as active,
      SUM(CASE WHEN status='PENDING_PAYMENT' THEN 1 ELSE 0 END) as pending,
      SUM(CASE WHEN status='PENDING_CONFIRM' THEN 1 ELSE 0 END) as unconfirmed
    FROM tokens
  `).get();

  const depositStats = db.prepare(`
    SELECT 
      COALESCE(SUM(sol_amount), 0) as total_deposited,
      COALESCE(SUM(fee_sol), 0) as total_fees,
      COALESCE(SUM(reward_sol), 0) as total_rewards,
      COUNT(*) as total_transactions
    FROM deposits
  `).get();

  const payoutStats = db.prepare(`
    SELECT 
      COALESCE(SUM(sol_amount), 0) as total_paid,
      COUNT(DISTINCT ca) as tokens_paid,
      COUNT(*) as total_payouts
    FROM payouts
  `).get();

  const holderStats = db.prepare(`
    SELECT 
      COUNT(*) as total_holders,
      COUNT(DISTINCT ca) as tokens_with_holders,
      COALESCE(SUM(total_paid), 0) as total_rewards_paid
    FROM holders
  `).get();

  const groupStats = db.prepare(`
    SELECT 
      COUNT(*) as total_groups,
      SUM(CASE WHEN active=1 THEN 1 ELSE 0 END) as active_groups
    FROM groups
  `).get();

  // Neue Statistik: Creator Pools
  const creatorPoolStats = db.prepare(`
    SELECT 
      COUNT(DISTINCT creator_tg_id) as unique_creators,
      COUNT(*) as creator_pools,
      COALESCE(SUM(sol_amount), 0) as total_creator_pools
    FROM creator_token_pools
  `).get();

  const msg = `üìä ADMIN SUMMARY

ü™ô TOKENS
Total: ${tokenStats.total}
Active: ${tokenStats.active}
Pending Payment: ${tokenStats.pending}
Unconfirmed: ${tokenStats.unconfirmed}

üí∞ FINANCIAL
Total Deposited: ${fmtSol(depositStats.total_deposited)} SOL
Total Fees: ${fmtSol(depositStats.total_fees)} SOL
Total Rewards Pool: ${fmtSol(depositStats.total_rewards)} SOL
Total Paid Out: ${fmtSol(payoutStats.total_paid)} SOL
Total Rewards Paid: ${fmtSol(holderStats.total_rewards_paid)} SOL

üë®‚Äçüé® CREATOR POOLS (NEU)
Unique Creators: ${creatorPoolStats.unique_creators}
Creator Pools: ${creatorPoolStats.creator_pools}
Total Creator Pools: ${fmtSol(creatorPoolStats.total_creator_pools)} SOL

üë• HOLDERS
Total Holders: ${holderStats.total_holders}
Tokens with Holders: ${holderStats.tokens_with_holders}

üì¢ GROUPS
Total Groups: ${groupStats.total_groups}
Active Groups: ${groupStats.active_groups}`;

  await ctx.reply(msg, adminHomeKeyboard());
}

async function executeAdminPayout(ctx) {
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');

  await ctx.reply('üöÄ Starting manual payout for all active tokens...');

  try {
    const result = await manualPayoutAllTokens();
    
    let msg = `üí∞ MANUAL PAYOUT COMPLETE\n\n`;
    msg += `Status: ${result.success ? '‚úÖ SUCCESS' : '‚ö†Ô∏è PARTIAL'}\n`;
    msg += `Message: ${result.message}\n`;
    msg += `Total Paid: ${fmtSol(result.totalPaid || 0)} SOL\n`;
    msg += `Recipients: ${result.totalRecipients || 0}\n`;
    msg += `Tokens Processed: ${result.results?.length || 0}\n\n`;
    
    if (result.results?.length > 0) {
      msg += `Token Results:\n`;
      result.results.forEach((r, idx) => {
        msg += `${idx+1}. ${r.tokenName || r.tokenCA.slice(0, 8)} (Creator ${r.creatorId}): ${fmtSol(r.paid || 0)} SOL to ${r.recipients || 0} holders\n`;
      });
    }
    
    await ctx.reply(msg, adminHomeKeyboard());
  } catch (error) {
    await ctx.reply(`‚ùå Payout failed: ${error.message}`, adminHomeKeyboard());
  }
}

async function renderAdminTokens(ctx, page = 0) {
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');

  const rows = db.prepare(`
    SELECT t.ca, t.status, t.created_at, t.creator_tg_id, t.creator_username,
           COALESCE(tm.display_name, tm.name) as name,
           COALESCE(tm.display_symbol, tm.symbol) as symbol,
           (SELECT COALESCE(SUM(reward_sol),0) FROM deposits d WHERE d.ca=t.ca) as total_pool,
           (SELECT COALESCE(sol_amount,0) FROM creator_token_pools WHERE creator_tg_id=t.creator_tg_id AND token_ca=t.ca) as creator_pool,
           (SELECT COUNT(*) FROM holders h WHERE h.ca=t.ca) as holder_count
    FROM tokens t
    LEFT JOIN token_meta tm ON tm.ca=t.ca
    ORDER BY t.created_at DESC
  `).all();

  console.log(`üìä Found ${rows.length} tokens in database`);

  if (!rows.length) {
    return ctx.reply('ü™ô No tokens in database.', adminHomeKeyboard());
  }

  const pageSize = 5;
  const currentPage = Math.max(0, Number(page || 0));
  const startIdx = currentPage * pageSize;
  const endIdx = startIdx + pageSize;
  const slice = rows.slice(startIdx, endIdx);
  const maxPage = Math.max(0, Math.ceil(rows.length / pageSize) - 1);

  let msg = `ü™ô Admin Token Management (${currentPage + 1}/${maxPage + 1})\n\n`;
  
  slice.forEach((r, idx) => {
    const name = r.name || 'Unknown';
    const symbol = r.symbol ? `$${r.symbol}` : 'N/A';
    const totalPool = Number(r.total_pool || 0);
    const creatorPool = Number(r.creator_pool || 0);
    const date = new Date(r.created_at).toLocaleDateString();
    
    msg += `${startIdx + idx + 1}. ${name} (${symbol})\n`;
    msg += `   Status: ${r.status}\n`;
    msg += `   Creator: ${r.creator_username || r.creator_tg_id}\n`;
    msg += `   Total Pool: ${fmtSol(totalPool)} SOL\n`;
    msg += `   Creator Pool: ${fmtSol(creatorPool)} SOL üéØ\n`;
    msg += `   Holders: ${r.holder_count}\n`;
    msg += `   Created: ${date}\n`;
    msg += `   CA: ${monospace(r.ca.slice(0, 12) + '...')}\n\n`;
  });

  // Navigation buttons with unique callback data
  const nav = [];
  if (currentPage > 0) {
    nav.push(Markup.button.callback('‚óÄÔ∏è Back', `ADM_TOKENS_PREV:${currentPage - 1}`));
  }
  if (currentPage < maxPage) {
    nav.push(Markup.button.callback('Next ‚ñ∂Ô∏è', `ADM_TOKENS_NEXT:${currentPage + 1}`));
  }

  // Create token selection buttons with UNIQUE callback data
  const tokenButtons = slice.map((r, idx) => [
    Markup.button.callback(`Token ${startIdx + idx + 1}`, `ADMIN_TOKEN_SELECT:${r.ca}:${currentPage}:${idx}`)
  ]);

  const keyboardRows = [
    ...tokenButtons,
    ...(nav.length > 0 ? [nav] : []),
    [Markup.button.callback('üè† Home', CB.HOME)],
  ];

  const kb = Markup.inlineKeyboard(keyboardRows);

  try {
    // If it's a callback query, edit the message
    if (ctx.callbackQuery) {
      await ctx.editMessageText(msg, {
        reply_markup: kb.reply_markup,
        parse_mode: 'Markdown'
      });
    } else {
      // If it's a regular message, reply
      await ctx.reply(msg, {
        reply_markup: kb.reply_markup,
        parse_mode: 'Markdown'
      });
    }
  } catch (error) {
    console.log('‚ùå Error rendering admin tokens:', error.message);
    // Fallback: send new message
    await ctx.reply(msg, {
      reply_markup: kb.reply_markup,
      parse_mode: 'Markdown'
    });
  }
}

// Aktualisierter Token Select Handler mit unique callback
bot.action(/^ADMIN_TOKEN_SELECT:(.+):(\d+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  const token = getToken(tokenCA);
  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const creatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  const totalFunded = getTotalFunded(tokenCA);
  const holderCount = countHoldersForToken(tokenCA);
  
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  const msg = `ü™ô ADMIN TOKEN DETAILS

Name: ${displayName}
Symbol: ${displaySymbol ? `$${displaySymbol}` : 'N/A'}
CA: ${monospace(tokenCA)}

Status: ${token?.status || 'UNKNOWN'}
Creator: ${token?.creator_username || token?.creator_tg_id}
Created: ${new Date(token?.created_at || 0).toLocaleString()}

Market Cap: ${formatMc(Number(meta?.last_mc || 0))} üíé
CREATOR POOL: ${fmtSol(creatorPool)} SOL üéØ
Total Funded: ${fmtSol(totalFunded)} SOL
Registered Holders: ${holderCount} üë•

Pump.fun: ${meta?.pump_url || 'N/A'}
DexScreener: ${meta?.dex_url || 'N/A'}

Choose action:`;
  
  await ctx.reply(msg, adminTokenActionsKeyboard(tokenCA, backPage));
});

// Behalte den alten Handler f√ºr Kompatibilit√§t
bot.action(/^ADMIN_TOKEN:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = Number(ctx.match[2] || 0);
  
  const token = getToken(tokenCA);
  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const creatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  const totalFunded = getTotalFunded(tokenCA);
  const holderCount = countHoldersForToken(tokenCA);
  
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  const msg = `ü™ô ADMIN TOKEN DETAILS

Name: ${displayName}
Symbol: ${displaySymbol ? `$${displaySymbol}` : 'N/A'}
CA: ${monospace(tokenCA)}

Status: ${token?.status || 'UNKNOWN'}
Creator: ${token?.creator_username || token?.creator_tg_id}
Created: ${new Date(token?.created_at || 0).toLocaleString()}

Market Cap: ${formatMc(Number(meta?.last_mc || 0))} üíé
CREATOR POOL: ${fmtSol(creatorPool)} SOL üéØ
Total Funded: ${fmtSol(totalFunded)} SOL
Registered Holders: ${holderCount} üë•

Pump.fun: ${meta?.pump_url || 'N/A'}
DexScreener: ${meta?.dex_url || 'N/A'}

Choose action:`;
  
  await ctx.reply(msg, adminTokenActionsKeyboard(tokenCA, backPage));
});

async function renderAdminGroups(ctx, page = 0) {
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');

  const rows = db.prepare(`
    SELECT chat_id, title, active, created_at, last_error
    FROM groups
    ORDER BY created_at DESC
  `).all();

  if (!rows.length) {
    return safeEditOrReply(ctx, 'üë• No groups in database.', adminHomeKeyboard());
  }

  const { page: p, maxPage, slice } = paginateRows(rows, page, 5);

  let msg = `üë• Admin Group Management (${p + 1}/${maxPage + 1})\n\n`;
  slice.forEach((r, idx) => {
    const title = r.title || 'No Title';
    const status = r.active ? '‚úÖ ACTIVE' : '‚ùå INACTIVE';
    const date = new Date(r.created_at).toLocaleDateString();
    const error = r.last_error ? `\n   Error: ${r.last_error.slice(0, 50)}...` : '';
    
    msg += `${idx+1}. ${title}\n`;
    msg += `   Chat ID: ${r.chat_id}\n`;
    msg += `   Status: ${status}\n`;
    msg += `   Created: ${date}${error}\n\n`;
  });

  const nav = [];
  if (p > 0) nav.push(Markup.button.callback('‚óÄÔ∏è Back', `${CB.ADM_GROUPS}:${p - 1}`));
  if (p < maxPage) nav.push(Markup.button.callback('Next ‚ñ∂Ô∏è', `${CB.ADM_GROUPS}:${p + 1}`));

  const kb = Markup.inlineKeyboard([
    ...(nav.length ? [nav] : []),
    [Markup.button.callback('üîÑ Sync All Groups', 'ADMIN_SYNC_GROUPS')],
    [Markup.button.callback('üè† Home', CB.HOME)],
  ]);

  await safeEditOrReply(ctx, msg, kb, 0);
}

bot.action('ADMIN_SYNC_GROUPS', async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return ctx.reply('‚õî No access.');
  
  await ctx.reply('üîÑ Syncing all groups... This may take a moment.');
  await ctx.reply('‚úÖ Group sync function would resync all groups here.', adminHomeKeyboard());
});

bot.action(/^AR:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  await postToChannelAndGroups(tokenCA, 'üîÑ Reposted by admin');
  await ctx.reply('‚úÖ Token reposted!', adminTokenActionsKeyboard(tokenCA, backPage));
});

bot.action(/^PAYTOKEN:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  
  await ctx.reply(`üí∞ Processing payouts for token ${tokenCA.slice(0, 8)}...`);
  
  try {
    const result = await executePayoutsForToken(tokenCA);
    
    let msg = `üí∞ PAYOUT RESULTS\n\n`;
    msg += `Token: ${tokenCA.slice(0, 8)}...\n`;
    msg += `Status: ${result.success ? '‚úÖ SUCCESS' : '‚ùå FAILED'}\n`;
    msg += `Message: ${result.message}\n`;
    msg += `Paid: ${fmtSol(result.paid || 0)} SOL\n`;
    msg += `Recipients: ${result.recipients || 0}\n`;
    
    if (result.transactions?.length > 0) {
      const successful = result.transactions.filter(t => t.success).length;
      const failed = result.transactions.filter(t => !t.success).length;
      msg += `\nTransactions: ${successful} ‚úÖ, ${failed} ‚ùå`;
    }
    
    await ctx.reply(msg, adminHomeKeyboard());
  } catch (error) {
    await ctx.reply(`‚ùå Payout failed: ${error.message}`, adminHomeKeyboard());
  }
});

bot.action(/^CALCPAY:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  await ctx.reply(`üßÆ Calculating payouts for token...`);
  
  try {
    const calculation = await calculatePayoutsForToken(tokenCA);
    
    let msg = `üßÆ PAYOUT CALCULATION\n\n`;
    msg += `Token: ${tokenCA.slice(0, 8)}...\n`;
    const token = getToken(tokenCA);
    msg += `Creator: ${token?.creator_tg_id || 'Unknown'}\n`;
    msg += `Creator Pool: ${fmtSol(calculation.pool || 0)} SOL\n`;
    msg += `Daily Payout (20%): ${fmtSol((calculation.pool || 0) * 0.20)} SOL\n`;
    msg += `Total Payout: ${fmtSol(calculation.totalPayout || 0)} SOL\n`;
    msg += `Eligible Recipients: ${calculation.recipients?.length || 0}\n`;
    msg += `Message: ${calculation.message}\n\n`;
    
    if (calculation.recipients?.length > 0) {
      msg += `Top 5 recipients:\n`;
      calculation.recipients.slice(0, 5).forEach((r, idx) => {
        msg += `${idx+1}. ${r.wallet.slice(0, 8)}...: ${fmtSol(r.amount)} SOL (${r.share.toFixed(2)}%)\n`;
      });
    }
    
    await ctx.reply(msg, adminTokenActionsKeyboard(tokenCA, backPage));
  } catch (error) {
    await ctx.reply(`‚ùå Calculation failed: ${error.message}`, adminTokenActionsKeyboard(tokenCA, backPage));
  }
});

bot.action(/^AX:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  db.prepare(`UPDATE holders SET last_notified_at=0, last_notification_type=NULL WHERE ca=?`).run(tokenCA);
  
  await ctx.reply('‚úÖ Holder alerts reset for this token.', adminTokenActionsKeyboard(tokenCA, backPage));
});

bot.action(/^AA:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  db.prepare(`UPDATE tokens SET status='ACTIVE' WHERE ca=?`).run(tokenCA);
  
  await ctx.reply('‚úÖ Token activated.', adminTokenActionsKeyboard(tokenCA, backPage));
});

bot.action(/^AI:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  db.prepare(`UPDATE tokens SET status='INACTIVE' WHERE ca=?`).run(tokenCA);
  
  await ctx.reply('‚úÖ Token inactivated.', adminTokenActionsKeyboard(tokenCA, backPage));
});

bot.action(/^AD:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  const confirmKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback('‚úÖ YES DELETE', `AD_CONFIRM:${tokenCA}:${backPage}`)],
    [Markup.button.callback('‚ùå Cancel', `${CB.ADM_TOKENS}:${backPage}`)],
  ]);
  
  await ctx.reply(
`‚ö†Ô∏è CONFIRM DELETE TOKEN ‚ö†Ô∏è

This will delete token ${tokenCA.slice(0, 8)}...
‚Ä¢ Token record
‚Ä¢ Meta data
‚Ä¢ Holder registrations
‚Ä¢ Deposit history
‚Ä¢ Payout history
‚Ä¢ Creator pool data

This action cannot be undone!

Type "DELETE" to confirm:`,
    confirmKeyboard
  );
});

bot.action(/^AD_CONFIRM:(.+):(\d+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  if (!isAdmin(ctx)) return;
  
  const tokenCA = ctx.match[1];
  const backPage = ctx.match[2];
  
  db.prepare('BEGIN TRANSACTION').run();
  try {
    const token = getToken(tokenCA);
    if (token) {
      // Creator pool auch l√∂schen
      db.prepare(`DELETE FROM creator_token_pools WHERE creator_tg_id=? AND token_ca=?`).run(token.creator_tg_id, tokenCA);
      db.prepare(`DELETE FROM creator_payouts WHERE creator_tg_id=? AND token_ca=?`).run(token.creator_tg_id, tokenCA);
    }
    
    db.prepare(`DELETE FROM tokens WHERE ca=?`).run(tokenCA);
    db.prepare(`DELETE FROM token_meta WHERE ca=?`).run(tokenCA);
    db.prepare(`DELETE FROM holders WHERE ca=?`).run(tokenCA);
    db.prepare(`DELETE FROM deposits WHERE ca=?`).run(tokenCA);
    db.prepare(`DELETE FROM payouts WHERE ca=?`).run(tokenCA);
    db.prepare('COMMIT').run();
    
    await ctx.reply(`‚úÖ Token ${tokenCA.slice(0, 8)}... deleted.`, Markup.inlineKeyboard([
      [Markup.button.callback('‚¨ÖÔ∏è Back to Tokens', `${CB.ADM_TOKENS}:${backPage}`)]
    ]));
  } catch (error) {
    db.prepare('ROLLBACK').run();
    await ctx.reply(`‚ùå Delete failed: ${error.message}`, adminTokenActionsKeyboard(tokenCA, backPage));
  }
});

/* =========================
   CREATOR PANEL - FIXED!
========================= */
bot.action(CB.CRE_HOME, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  await safeEditOrReply(ctx, 'üë®‚Äçüé® Creator Panel', creatorHomeKeyboard());
});

bot.action(CB.CRE_REG, async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  setState(ctx.from.id, { mode: 'creator_send_ca' });
  await ctx.reply(
`‚ûï Creator: Register Token ü™ô

Send your token CA (mint address).

Important:
‚Ä¢ Any Solana token can be registered üîó
‚Ä¢ Minimum deposit: 0.01 SOL üí∞
‚Ä¢ Fee: 10% of deposit (goes to fee wallet) üìä
‚Ä¢ 90% goes to YOUR creator rewards pool üéÅ

Paste your token CA now:`,
{ parse_mode: 'Markdown' }
  );
});

async function renderCreatorTokens(ctx, page = 0) {
  const uid = ctx.from.id;
  const rows = db.prepare(`
    SELECT t.ca, t.status, t.created_at, 
           COALESCE(tm.display_name, tm.name) as name, 
           COALESCE(tm.display_symbol, tm.symbol) as symbol,
           (SELECT COALESCE(sol_amount,0) FROM creator_token_pools WHERE creator_tg_id=t.creator_tg_id AND token_ca=t.ca) as creator_pool
    FROM tokens t
    LEFT JOIN token_meta tm ON tm.ca=t.ca
    WHERE t.creator_tg_id=?
    ORDER BY t.created_at DESC
  `).all(uid);

  if (!rows.length) {
    return safeEditOrReply(ctx, 'üóÇÔ∏è No tokens yet.\n\nRegister your first token to start! üöÄ', creatorHomeKeyboard());
  }

  const { page: p, maxPage, slice } = paginateRows(rows, page, 5);

  let msg = `üóÇÔ∏è My Tokens (${p + 1}/${maxPage + 1})\n\n`;
  slice.forEach((r, idx) => {
    const n = r.name || 'Unknown';
    const s = r.symbol ? `$${r.symbol}` : 'N/A';
    const creatorPool = Number(r.creator_pool || 0);
    const date = new Date(r.created_at).toLocaleDateString();
    
    msg += `${idx+1}. ${n} (${s})\n`;
    msg += `   Status: ${r.status}\n`;
    msg += `   Your Pool: ${fmtSol(creatorPool)} SOL üéØ\n`;
    msg += `   CA: ${monospace(r.ca.slice(0, 16) + '...')}\n`;
    msg += `   Created: ${date}\n\n`;
  });
  
  const pickButtons = slice.map((r, idx) => [Markup.button.callback(`üìù Token ${idx + 1}`, `MAN:${r.ca}`)]);

  const nav = [];
  if (p > 0) nav.push(Markup.button.callback('‚óÄÔ∏è Back', `${CB.CRE_LIST}:${p - 1}`));
  if (p < maxPage) nav.push(Markup.button.callback('Next ‚ñ∂Ô∏è', `${CB.CRE_LIST}:${p + 1}`));

  const kb = Markup.inlineKeyboard([
    ...pickButtons,
    ...(nav.length ? [nav] : []),
    [Markup.button.callback('‚ûï New Token', CB.CRE_REG)],
    [Markup.button.callback('üè† Start', CB.HOME)],
  ]);

  await safeEditOrReply(ctx, msg, kb, 0);
}

bot.action(new RegExp(`^${CB.CRE_LIST}:(\\d+)$`), async (ctx) => {
  await safeAnswerCb(ctx);
  await renderCreatorTokens(ctx, Number(ctx.match[1] || 0));
});

bot.action(/^MAN:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) return ctx.reply('‚ö†Ô∏è Not your token.');

  const meta = getMeta(tokenCA) || await refreshMetaPriority(tokenCA);
  const creatorPool = getCreatorTokenPool(uid, tokenCA);
  const status = getToken(tokenCA)?.status || 'UNKNOWN';
  const holders = countHoldersForToken(tokenCA);
  const mc = Number(meta?.last_mc || 0);
  const totalFunded = getTotalFunded(tokenCA);

  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';

  await ctx.reply(
`üë®‚Äçüé® Manage Token

Name: ${displayName}
Symbol: ${displaySymbol ? `$${displaySymbol}` : 'N/A'}
CA: ${monospace(tokenCA)}

Status: ${status}
Market Cap: ${formatMc(mc)} üíé
YOUR Rewards Pool: ${fmtSol(creatorPool)} SOL üéØ
Total Funded: ${fmtSol(totalFunded)} SOL
Registered holders: ${holders} üë•

Next step ‚úÖ
- Deposit must be confirmed before posting.

Choose an action below:`,
    creatorManageKeyboard(tokenCA)
  );
});

/* =========================
   CREATOR ACTION HANDLERS - NEWLY ADDED!
========================= */

// Creator Stats Handler - AKTUALISIERT f√ºr Creator Pools
bot.action(/^CST:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('‚ö†Ô∏è Not your token.', creatorHomeKeyboard());
  }

  const token = getToken(tokenCA);
  const meta = getMeta(tokenCA);
  const creatorStats = getCreatorTokenStats(uid, tokenCA);
  const holderCount = countHoldersForToken(tokenCA);
  
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  // Get recent payouts from creator pool
  const recentPayouts = db.prepare(`
    SELECT COUNT(*) as count, COALESCE(SUM(sol_amount), 0) as total 
    FROM creator_payouts 
    WHERE creator_tg_id=? AND token_ca=? AND paid_at > ?
  `).get(uid, tokenCA, now() - 7 * 24 * 60 * 60 * 1000);

  const recentHolders = db.prepare(`
    SELECT COUNT(*) as count 
    FROM holders 
    WHERE ca=? AND registered_at > ?
  `).get(tokenCA, now() - 7 * 24 * 60 * 60 * 1000);

  const msg = `üìä TOKEN STATISTICS

ü™ô Token: ${displayName} (${displaySymbol ? `$${displaySymbol}` : 'N/A'})
üìà Status: ${token?.status || 'UNKNOWN'}
üìÖ Created: ${new Date(token?.created_at || 0).toLocaleDateString()}

üí∞ YOUR FINANCIAL (Creator-isoliert)
‚Ä¢ Your Rewards Pool: ${fmtSol(creatorStats.pool)} SOL üéØ
‚Ä¢ Your Total Deposited: ${fmtSol(creatorStats.totalDeposited)} SOL
‚Ä¢ Your Total Paid Out: ${fmtSol(creatorStats.totalPaid)} SOL
‚Ä¢ Market Cap: ${formatMc(Number(meta?.last_mc || 0))}

üë• HOLDERS
‚Ä¢ Total Registered: ${holderCount}
‚Ä¢ New (7 days): ${recentHolders?.count || 0}

üéÅ YOUR PAYOUTS
‚Ä¢ Recent (7 days): ${recentPayouts?.count || 0} payments
‚Ä¢ Amount: ${fmtSol(recentPayouts?.total || 0)} SOL

üîó Links:
‚Ä¢ Pump.fun: ${meta?.pump_url || 'N/A'}
‚Ä¢ Chart: ${meta?.dex_url || 'N/A'}`;

  await ctx.reply(msg, creatorManageKeyboard(tokenCA));
});

// Creator Report Handler - AKTUALISIERT
bot.action(/^REP:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('‚ö†Ô∏è Not your token.', creatorHomeKeyboard());
  }

  const token = getToken(tokenCA);
  const meta = getMeta(tokenCA);
  const creatorStats = getCreatorTokenStats(uid, tokenCA);
  const holderCount = countHoldersForToken(tokenCA);
  
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  // Get all deposits for this creator
  const deposits = db.prepare(`
    SELECT signature, sol_amount, fee_sol, reward_sol, created_at 
    FROM deposits 
    WHERE ca=? 
    ORDER BY created_at DESC
  `).all(tokenCA);
  
  // Get creator payouts
  const creatorPayouts = db.prepare(`
    SELECT holder_wallet, sol_amount, paid_at 
    FROM creator_payouts 
    WHERE creator_tg_id=? AND token_ca=?
    ORDER BY paid_at DESC
    LIMIT 10
  `).all(uid, tokenCA);
  
  let msg = `üìã TOKEN REPORT (Your Creator Pool)

ü™ô Token: ${displayName} (${displaySymbol ? `$${displaySymbol}` : 'N/A'})
üìà Status: ${token?.status || 'UNKNOWN'}
üí∞ YOUR Rewards Pool: ${fmtSol(creatorStats.pool)} SOL üéØ
üë• Registered Holders: ${holderCount}

üì• YOUR DEPOSITS (${deposits.length}):\n`;
  
  deposits.forEach((dep, idx) => {
    if (idx < 5) {
      const date = new Date(dep.created_at).toLocaleDateString();
      msg += `‚Ä¢ ${date}: ${fmtSol(dep.sol_amount)} SOL (Fee: ${fmtSol(dep.fee_sol)} SOL)\n`;
    }
  });
  
  if (deposits.length > 5) {
    msg += `‚Ä¢ ... and ${deposits.length - 5} more deposits\n`;
  }
  
  msg += `\nüì§ YOUR RECENT PAYOUTS (${creatorPayouts.length}):\n`;
  
  if (creatorPayouts.length > 0) {
    creatorPayouts.forEach((payout, idx) => {
      if (idx < 3) {
        const date = new Date(payout.paid_at).toLocaleDateString();
        const walletShort = payout.holder_wallet.slice(0, 8) + '...' + payout.holder_wallet.slice(-4);
        msg += `‚Ä¢ ${date}: ${fmtSol(payout.sol_amount)} SOL to ${walletShort}\n`;
      }
    });
    
    if (creatorPayouts.length > 3) {
      msg += `‚Ä¢ ... and ${creatorPayouts.length - 3} more payouts\n`;
    }
  } else {
    msg += `‚Ä¢ No payouts from your pool yet\n`;
  }
  
  msg += `\nüìä Your Total Deposited: ${fmtSol(creatorStats.totalDeposited)} SOL`;
  msg += `\nüìä Your Total Paid: ${fmtSol(creatorStats.totalPaid)} SOL`;
  msg += `\nüìà Market Cap: ${formatMc(Number(meta?.last_mc || 0))}`;

  await ctx.reply(msg, creatorManageKeyboard(tokenCA));
});

// Creator Holder Stats Handler
bot.action(/^CHS:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('‚ö†Ô∏è Not your token.', creatorHomeKeyboard());
  }

  const holders = db.prepare(`
    SELECT h.wallet, h.registered_at, h.total_paid, h.last_paid_at, h.username,
           (SELECT COUNT(*) FROM holders h2 WHERE h2.ca=h.ca) as total_holders
    FROM holders h
    WHERE h.ca=?
    ORDER BY h.registered_at DESC
    LIMIT 20
  `).all(tokenCA);
  
  const totalHolders = holders.length > 0 ? holders[0].total_holders : 0;
  const meta = getMeta(tokenCA);
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  const displaySymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  let msg = `üë§ HOLDER STATISTICS

ü™ô Token: ${displayName} (${displaySymbol ? `$${displaySymbol}` : 'N/A'})
üìä Total Holders: ${totalHolders}

üìã RECENT REGISTRATIONS:\n`;
  
  if (holders.length > 0) {
    holders.forEach((holder, idx) => {
      if (idx < 10) {
        const walletShort = holder.wallet.slice(0, 8) + '...' + holder.wallet.slice(-4);
        const registered = new Date(holder.registered_at).toLocaleDateString();
        const holdHours = ((now() - holder.registered_at) / (1000 * 60 * 60)).toFixed(1);
        const totalPaid = fmtSol(holder.total_paid || 0);
        
        msg += `\n${idx+1}. ${walletShort}`;
        if (holder.username) msg += ` (@${holder.username})`;
        msg += `\n   üìÖ Registered: ${registered}`;
        msg += `\n   ‚è∞ Hold time: ${holdHours}h`;
        msg += `\n   üí∞ Earned: ${totalPaid} SOL`;
      }
    });
    
    if (holders.length > 10) {
      msg += `\n\n... and ${holders.length - 10} more holders`;
    }
  } else {
    msg += `\nNo holders registered yet.`;
  }
  
  // Get top earners from this creator's pool
  const topEarners = db.prepare(`
    SELECT h.wallet, h.total_paid, h.username
    FROM holders h
    WHERE h.ca=? AND h.total_paid > 0
    ORDER BY h.total_paid DESC
    LIMIT 5
  `).all(tokenCA);
  
  if (topEarners.length > 0) {
    msg += `\n\nüèÜ TOP EARNERS:\n`;
    topEarners.forEach((earner, idx) => {
      const walletShort = earner.wallet.slice(0, 8) + '...' + earner.wallet.slice(-4);
      msg += `\n${idx+1}. ${walletShort}: ${fmtSol(earner.total_paid || 0)} SOL`;
      if (earner.username) msg += ` (@${earner.username})`;
    });
  }

  await ctx.reply(msg, creatorManageKeyboard(tokenCA));
});

// Creator Edit Display Handler
bot.action(/^EDN:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('‚ö†Ô∏è Not your token.', creatorHomeKeyboard());
  }

  const meta = getMeta(tokenCA);
  const currentName = meta?.display_name || meta?.name || 'Unknown';
  const currentSymbol = meta?.display_symbol || meta?.symbol || 'N/A';
  
  // Set state for text handler
  setState(uid, { mode: 'creator_edit_name', tempTokenCA: tokenCA });
  
  await ctx.reply(
`üé® EDIT DISPLAY NAME/SYMBOL

Current name: ${currentName}
Current symbol: ${currentSymbol}

Please send the NEW name (max 64 characters):

Example: "WhiteMeme Token", "CryptoPump", etc.`,
    creatorManageKeyboard(tokenCA)
  );
});

// Creator Deactivate Handler
bot.action(/^DEA:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('‚ö†Ô∏è Not your token.', creatorHomeKeyboard());
  }

  const token = getToken(tokenCA);
  if (!token) return ctx.reply('‚ö†Ô∏è Token not found.', creatorHomeKeyboard());
  
  const meta = getMeta(tokenCA);
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  
  const confirmKeyboard = Markup.inlineKeyboard([
    [Markup.button.callback('‚úÖ YES, DEACTIVATE', `DEA_CONFIRM:${tokenCA}`)],
    [Markup.button.callback('‚ùå Cancel', `MAN:${tokenCA}`)],
  ]);
  
  await ctx.reply(
`üö´ DEACTIVATE TOKEN ‚ö†Ô∏è

Token: ${displayName}
CA: ${tokenCA.slice(0, 12)}...

‚ö†Ô∏è WARNING:
‚Ä¢ Token will be marked INACTIVE
‚Ä¢ No more payouts from YOUR pool will be processed
‚Ä¢ Your existing creator pool remains
‚Ä¢ Holders cannot earn new rewards from your pool
‚Ä¢ Can be reactivated by admin

Are you sure you want to deactivate this token?`,
    confirmKeyboard
  );
});

// Creator Deactivate Confirmation Handler
bot.action(/^DEA_CONFIRM:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('‚ö†Ô∏è Not your token.', creatorHomeKeyboard());
  }

  db.prepare(`UPDATE tokens SET status='INACTIVE' WHERE ca=?`).run(tokenCA);
  
  const meta = getMeta(tokenCA);
  const displayName = meta?.display_name || meta?.name || 'Unknown';
  
  await ctx.reply(
`‚úÖ Token deactivated: ${displayName}

The token has been marked as INACTIVE.
‚Ä¢ No new payouts from YOUR pool will be processed
‚Ä¢ Your existing creator pool remains
‚Ä¢ Holders will be notified
‚Ä¢ Contact admin to reactivate`,
    creatorManageKeyboard(tokenCA)
  );
});

/* =========================
   CONFIRM / CANCEL
========================= */
bot.action(/^CONF:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  const t = getToken(tokenCA);
  if (!t) return ctx.reply('‚ö†Ô∏è Token not found.');
  if (t.creator_tg_id !== uid) return ctx.reply('‚ö†Ô∏è Only the creator can confirm.');

  db.prepare(`UPDATE tokens SET status='PENDING_PAYMENT' WHERE ca=?`).run(tokenCA);

  await ctx.reply(
`‚úÖ Token confirmed! üéâ

üí∏ Next step: Deposit required
Send SOL to the Reward Wallet:
${monospace(REWARD_WALLET)}

Minimum: 0.01 SOL üí∞
Fee: 10% (sent to fee wallet) üìä
Rewards: 90% added to YOUR creator pool üéØ

Then open "Deposit / Check Payment" and paste your Solscan TX link. üîé`,
    creatorManageKeyboard(tokenCA)
  );
});

bot.action('CXL', async (ctx) => {
  await safeAnswerCb(ctx);
  clearState(ctx.from.id);
  await ctx.reply('‚ùå Cancelled.', creatorHomeKeyboard());
});

/* =========================
   DEPOSIT / CHECK (AKTUALISIERT f√ºr Creator Pools)
========================= */
bot.action(/^DEP:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) return ctx.reply('‚ö†Ô∏è Not your token.');
  const t = getToken(tokenCA);
  if (!t) return ctx.reply('‚ö†Ô∏è Token not found.');
  if (t.status === 'PENDING_CONFIRM') return ctx.reply('‚ö†Ô∏è Please confirm the token first.');

  setState(uid, { mode: 'wait_payment_tx', tempTokenCA: tokenCA });

  await ctx.reply(
`üí∏ Deposit / Payment

Send SOL to Reward Wallet:
${monospace(REWARD_WALLET)}

Requirements:
‚Ä¢ Minimum deposit: 0.01 SOL üí∞
‚Ä¢ Service fee: 10% (sent to fee wallet) üìä
‚Ä¢ Rewards added: 90% to YOUR creator pool üéØ

How to pay:
1. Send SOL to address above
2. Go to solscan.io
3. Copy the transaction link
4. Paste it here
5. Click "Check Payment" button

Now paste your Solscan TX link here. üîç`,
{ 
  parse_mode: 'Markdown',
  reply_markup: paymentKeyboard(tokenCA).reply_markup
}
  );
});

bot.action(/^CHK:(.+)$/, async (ctx) => {
  await safeAnswerCb(ctx);
  const tokenCA = ctx.match[1];
  const uid = ctx.from.id;

  if (!creatorOwnsToken(uid, tokenCA)) {
    return ctx.reply('‚ö†Ô∏è Not your token.', creatorManageKeyboard(tokenCA));
  }

  const s = getState(uid);
  if (!s?.tempSig || s?.tempTokenCA !== tokenCA) {
    return ctx.reply('‚ö†Ô∏è Please paste your Solscan TX link first, then click "Check Payment".', creatorManageKeyboard(tokenCA));
  }

  const sig = s.tempSig;

  const already = db.prepare(`SELECT signature FROM deposits WHERE signature=?`).get(sig);
  if (already) {
    clearState(uid);
    return ctx.reply('‚úÖ Transaction already confirmed and processed.', creatorManageKeyboard(tokenCA));
  }

  let verification;
  try {
    verification = await verifyDepositTx(sig, REWARD_WALLET);
  } catch (e) {
    return ctx.reply(`‚ö†Ô∏è Could not verify transaction. Error: ${String(e?.message || e)}`, creatorManageKeyboard(tokenCA));
  }

  if (!verification.ok) {
    return ctx.reply(`‚ö†Ô∏è Payment not confirmed. Reason: ${verification.reason}`, creatorManageKeyboard(tokenCA));
  }

  const solAmount = verification.solAmount;
  if (solAmount < 0.01) {
    return ctx.reply('‚ö†Ô∏è Deposit too small. Minimum is 0.01 SOL.', creatorManageKeyboard(tokenCA));
  }

  const feeSol = solAmount * 0.10;
  const rewardSol = solAmount * 0.90;

  let feeSig = null;
  try {
    feeSig = await sendFeeTransfer(feeSol);
    console.log(`‚úÖ Fee sent: ${feeSig}`);
  } catch (feeError) {
    console.log(`‚ö†Ô∏è Fee transfer failed: ${feeError.message}`);
    return ctx.reply('‚ö†Ô∏è Fee transfer failed. Please try again.', creatorManageKeyboard(tokenCA));
  }

  db.prepare(`
    INSERT INTO deposits (signature, ca, from_wallet, sol_amount, fee_sol, reward_sol, fee_sig, created_at, creator_tg_id)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(sig, tokenCA, verification.fromWallet || '', solAmount, feeSol, rewardSol, feeSig || '', now(), uid);

  // WICHTIG: Creator-Pool aktualisieren (nur dieser Creator!)
  const token = getToken(tokenCA);
  if (token) {
    updateCreatorTokenPool(token.creator_tg_id, tokenCA, rewardSol);
  }

  db.prepare(`UPDATE tokens SET status='ACTIVE' WHERE ca=?`).run(tokenCA);

  await refreshMetaPriority(tokenCA);

  const meta = getMeta(tokenCA);
  if (!meta?.base_mc || Number(meta.base_mc) <= 0) {
    try {
      const pair = await fetchDexPair(tokenCA);
      const mc = pairMarketCap(pair);
      if (mc > 0) {
        db.prepare(`UPDATE token_meta SET base_mc=?, last_mc=?, last_checked_at=? WHERE ca=?`)
          .run(mc, mc, now(), tokenCA);
      }
    } catch {}
  }

  clearState(uid);

  console.log(`üöÄ STARTING POST after payment for: ${tokenCA}`);
  await postToChannelAndGroups(tokenCA, '‚úÖ Activated (deposit confirmed) üéâ');

  const newCreatorPool = token ? getCreatorTokenPool(token.creator_tg_id, tokenCA) : 0;
  
  await ctx.reply(
`‚úÖ Deposit confirmed! üéâ

Deposit: ${fmtSol(solAmount)} SOL üí∞
Added to YOUR pool: ${fmtSol(rewardSol)} SOL üéØ
Your pool now: ${fmtSol(newCreatorPool)} SOL

üöÄ Post has been sent to Channel + Groups!

‚úÖ Token is now active and will be monitored.
üéóÔ∏è Auto-posts at 2x, 5x, 10x milestones!
üí∞ Payouts will ONLY come from YOUR creator pool.`,
    creatorManageKeyboard(tokenCA)
  );
});

/* =========================
   TEXT HANDLER (flows)
========================= */
bot.on('text', async (ctx) => {
  const uid = ctx.from.id;
  const s = getState(uid);
  const text = (ctx.message?.text || '').trim();

  if (!text || text.startsWith('/')) return;

  // CREATOR register
  if (s?.mode === 'creator_send_ca') {
    const ca = extractFirstPubkey(text);
    if (!ca) return ctx.reply('‚ö†Ô∏è Invalid mint address. Please paste only the CA.');

    if (tokenExists(ca)) {
      clearState(uid);
      return ctx.reply('‚ö†Ô∏è Token already exists. Open "My Tokens".', creatorHomeKeyboard());
    }

    db.prepare(`
      INSERT INTO tokens (ca, creator_tg_id, creator_username, status, created_at)
      VALUES (?, ?, ?, 'PENDING_CONFIRM', ?)
    `).run(ca, uid, ctx.from.username || '', now());

    const meta = await refreshMetaPriority(ca);
    clearState(uid);

    const name = meta?.display_name || meta?.name || 'Unknown';
    const symbol = meta?.display_symbol || meta?.symbol || 'N/A';
    const logo = meta?.logo_url;

    let confirmationMsg = `ü™ô Confirm this token\n\n`;
    if (logo) {
      confirmationMsg += `‚úÖ Token information retrieved successfully!\n\n`;
    }
    
    confirmationMsg += `Name: ${name}\n`;
    confirmationMsg += `Symbol: ${symbol ? `$${symbol}` : 'N/A'}\n`;
    confirmationMsg += `CA: ${monospace(ca)}\n\n`;
    confirmationMsg += `Posting happens ONLY after deposit is confirmed ‚úÖ\n\n`;
    confirmationMsg += `Payment wallet: ${monospace(REWARD_WALLET)}`;

    if (logo) {
      await ctx.replyWithPhoto(logo, {
        caption: confirmationMsg,
        parse_mode: 'Markdown',
        reply_markup: tokenConfirmKeyboard(ca).reply_markup
      });
    } else {
      await ctx.reply(confirmationMsg, {
        parse_mode: 'Markdown',
        reply_markup: tokenConfirmKeyboard(ca)
      });
    }
    
    return;
  }

  // HOLDER send token
  if (s?.mode === 'holder_send_token') {
    const ca = extractFirstPubkey(text);
    if (!ca) return ctx.reply('‚ö†Ô∏è Invalid token CA.');

    if (!tokenExists(ca)) return ctx.reply('‚ö†Ô∏è This token is not registered yet. Ask the creator to register it first.');

    try {
      const supply = await getMintSupplyAndDecimals(ca);
      const supplyUi = Number(supply.uiAmount || 0);
      const minUi = supplyUi * MIN_HOLDER_PCT;
      
      await ctx.reply(`üîç Checking token supply...\n\nMinimum required: ${minUi.toFixed(4)} tokens ü™ô\n\nNow send your wallet address to check your balance.`);
      
      setState(uid, { 
        mode: 'holder_send_wallet', 
        tempTokenCA: ca,
        tempMinRequired: minUi,
        tempSupplyUi: supplyUi
      });
    } catch (e) {
      await ctx.reply('‚ö†Ô∏è Could not fetch token supply. Please try again later.');
    }
    return;
  }

  // HOLDER send wallet
  if (s?.mode === 'holder_send_wallet') {
    const ca = s.tempTokenCA;
    const minRequired = s.tempMinRequired || 0;
    const wallet = extractFirstPubkey(text);
    if (!wallet) return ctx.reply('‚ö†Ô∏è Invalid wallet address.');

    try {
      const balance = await getWalletTokenBalanceUi(wallet, ca);
      const supplyUi = s.tempSupplyUi || 0;
      
      if (balance < minRequired) {
        const percentHeld = supplyUi > 0 ? (balance / supplyUi * 100).toFixed(6) : '0';
        const requiredPercent = (MIN_HOLDER_PCT * 100).toFixed(4);
        
        await ctx.reply(
`‚ö†Ô∏è Insufficient Balance

You hold: ${balance.toFixed(4)} tokens ü™ô
Required: ${minRequired.toFixed(4)} tokens ü™ô

Percentage held: ${percentHeld}%
Required: ${requiredPercent}%

You must hold at least ${requiredPercent}% of total supply to register.

Please acquire more tokens and try again.`,
          holderHomeKeyboard()
        );
        
        db.prepare(`
          UPDATE holders 
          SET last_notified_at=?, last_notification_type=? 
          WHERE ca=? AND wallet=?
        `).run(now(), 'insufficient_balance', ca, wallet);
        
        clearState(uid);
        return;
      }
      
      db.prepare(`
        INSERT INTO holders (ca, tg_id, username, wallet, registered_at)
        VALUES (?, ?, ?, ?, ?)
        ON CONFLICT(ca, wallet) DO UPDATE SET
          tg_id=excluded.tg_id,
          username=excluded.username,
          registered_at=excluded.registered_at,
          last_notified_at=0,
          last_notification_type=NULL
      `).run(ca, uid, ctx.from.username || '', wallet, now());

      // Send registration DM
      await sendRegistrationDM(uid, ca, wallet, balance, supplyUi);

      clearState(uid);

      const tm = getMeta(ca) || await refreshMetaPriority(ca);
      const displayName = tm?.display_name || tm?.name || 'Unknown';
      const displaySymbol = tm?.display_symbol || tm?.symbol || 'N/A';

      return ctx.reply(
`‚úÖ Registered successfully! üéâ

Token: ${displayName} (${displaySymbol ? `$${displaySymbol}` : 'N/A'})
CA: ${monospace(ca)}
Wallet: ${monospace(wallet)}
Your balance: ${balance.toFixed(4)} tokens ‚úÖ

‚úÖ Eligibility Rules
- Hold at least ${MIN_HOLD_HOURS} hours ‚è∞
- Hold at least ${(MIN_HOLDER_PCT * 100).toFixed(4)}% of supply ü™ô
- Do NOT sell during the holding period üìâ

üíé The longer you hold, the more rewards you earn!

üì® You will receive DM notifications for payouts!`,
        holderHomeKeyboard()
      );
    } catch (e) {
      await ctx.reply(`‚ö†Ô∏è Error checking balance: ${e.message}`);
      clearState(uid);
    }
    return;
  }

  // HOLDER remove token
  if (s?.mode === 'holder_remove_token') {
    const ca = extractFirstPubkey(text);
    if (!ca) return ctx.reply('‚ö†Ô∏è Invalid token CA.');
    setState(uid, { mode: 'holder_remove_wallet', tempTokenCA: ca });
    return ctx.reply('üóëÔ∏è Now send the wallet address to remove. üëõ\n\nPaste your wallet address:');
  }

  // HOLDER remove wallet
  if (s?.mode === 'holder_remove_wallet') {
    const ca = s.tempTokenCA;
    const wallet = extractFirstPubkey(text);
    if (!wallet) return ctx.reply('‚ö†Ô∏è Invalid wallet address.');

    const res = db.prepare(`DELETE FROM holders WHERE ca=? AND wallet=? AND tg_id=?`).run(ca, wallet, uid);
    clearState(uid);

    if (res.changes > 0) return ctx.reply('‚úÖ Registration removed.', holderHomeKeyboard());
    return ctx.reply('‚ö†Ô∏è Not found. Please double-check token + wallet.', holderHomeKeyboard());
  }

  // CREATOR edit name
  if (s?.mode === 'creator_edit_name') {
    const tokenCA = s.tempTokenCA;
    const uid = ctx.from.id;
    
    if (!creatorOwnsToken(uid, tokenCA)) {
      clearState(uid);
      return ctx.reply('‚ö†Ô∏è Not your token.', creatorHomeKeyboard());
    }

    const newName = text.slice(0, 64);
    setState(uid, { mode: 'creator_edit_symbol', tempTokenCA: tokenCA, tempName: newName });
    
    await ctx.reply(
`‚úÖ Name set to: ${newName}

Now send the new symbol (without $, max 15 characters):

Example: WHITE, MEME, BOT`,
      creatorManageKeyboard(tokenCA)
    );
    return;
  }

  // CREATOR edit symbol
  if (s?.mode === 'creator_edit_symbol') {
    const tokenCA = s.tempTokenCA;
    const uid = ctx.from.id;
    const newName = s.tempName;
    
    if (!creatorOwnsToken(uid, tokenCA)) {
      clearState(uid);
      return ctx.reply('‚ö†Ô∏è Not your token.', creatorHomeKeyboard());
    }

    const newSymbol = text.replace(/\$/g, '').slice(0, 15);
    
    db.prepare(`
      UPDATE token_meta 
      SET display_name=?, display_symbol=?
      WHERE ca=?
    `).run(newName, newSymbol, tokenCA);
    
    clearState(uid);
    
    await ctx.reply(
`‚úÖ Display name/symbol updated!

New name: ${newName}
New symbol: ${newSymbol}

Posts will now show: ${newName} #${newSymbol}`,
      creatorManageKeyboard(tokenCA)
    );
    return;
  }

  // PAYMENT: waiting tx
  if (s?.mode === 'wait_payment_tx') {
    const sig = extractSignatureFromText(text);
    if (!sig) return ctx.reply('‚ö†Ô∏è Please paste a Solscan TX link or a transaction signature.');
    
    setState(uid, { mode: 'wait_payment_check', tempTokenCA: s.tempTokenCA, tempSig: sig });
    
    await ctx.reply(
`‚úÖ TX received! üîç

Transaction signature: ${monospace(sig.slice(0, 16) + '...')}

Now click "Check Payment" button to confirm.`,
{ 
  parse_mode: 'Markdown',
  reply_markup: paymentKeyboard(s.tempTokenCA).reply_markup
}
    );
    return;
  }
});

/* =========================
   REST OF FUNCTIONS
========================= */
function getToken(ca) { return db.prepare(`SELECT * FROM tokens WHERE ca=?`).get(ca); }
function getMeta(ca) { return db.prepare(`SELECT * FROM token_meta WHERE ca=?`).get(ca); }
function tokenExists(ca) { return !!getToken(ca); }
function creatorOwnsToken(uid, ca) {
  return !!db.prepare(`SELECT ca FROM tokens WHERE ca=? AND creator_tg_id=?`).get(ca, uid);
}

// Behalte alte Funktion f√ºr Kompatibilit√§t, aber verwende Creator-Pools f√ºr Payouts
function getRewardsPool(ca) {
  const dep = db.prepare(`SELECT COALESCE(SUM(reward_sol),0) AS pool FROM deposits WHERE ca=?`).get(ca);
  const paid = db.prepare(`SELECT COALESCE(SUM(sol_amount),0) AS paid FROM payouts WHERE ca=?`).get(ca);
  return Math.max(0, Number(dep.pool || 0) - Number(paid.paid || 0));
}

function getTotalFunded(ca) {
  const row = db.prepare(`SELECT COALESCE(SUM(sol_amount),0) AS total FROM deposits WHERE ca=?`).get(ca);
  return Number(row.total || 0);
}

function getFeesTotal(ca) {
  const row = db.prepare(`SELECT COALESCE(SUM(fee_sol),0) AS total FROM deposits WHERE ca=?`).get(ca);
  return Number(row.total || 0);
}

function countHoldersForToken(ca) {
  const r = db.prepare(`SELECT COUNT(*) AS c FROM holders WHERE ca=?`).get(ca);
  return Number(r?.c || 0);
}

/* =========================
   LAUNCH BOT - VERBESSERTE VERSION!
========================= */
async function launchBot() {
  console.log('ü§ñ Starting üé≠ WHITEMEME Bot...');
  console.log(`üì¢ Channel: ${CHANNEL_ID}`);
  console.log(`üí∞ Reward Wallet: ${REWARD_WALLET}`);
  console.log(`üí≥ Fee Wallet: ${FEE_WALLET}`);
  console.log(`üîß Callback Keys:`, CB);
  
  // RUN AUTO MIGRATION FIRST
  runAutoMigration();
  
  try {
    console.log('üì¢ Starting broadcast worker...');
    startBroadcastWorker();
    
    console.log('üìà Starting milestone checker...');
    startMilestoneChecker();
    
    console.log('‚è∞ Starting auto-payout scheduler...');
    startAutoPayoutScheduler();
    
    await bot.launch({ dropPendingUpdates: true });
    console.log('‚úÖ Bot running! ‚úÖ');
    
    try {
      const chat = await bot.telegram.getChat(CHANNEL_ID);
      console.log(`‚úÖ Channel accessible: ${chat.title || 'Unknown'}`);
      
      const adminMsg = `ü§ñ üé≠ WHITEMEME Bot started ‚úÖ\n\n‚Ä¢ Channel: ${chat.title || CHANNEL_ID}\n‚Ä¢ Time: ${new Date().toLocaleString()}\n‚Ä¢ Posts sent IMMEDIATELY! üöÄ\n‚Ä¢ Reward Wallet: ${monospace(REWARD_WALLET)}\n‚Ä¢ Creator-isolated Pools: ACTIVATED üéØ\n‚Ä¢ Bonded Posting: ACTIVATED üéóÔ∏è\n‚Ä¢ Auto-Payouts: 20:00 UTC daily ‚è∞\n‚Ä¢ Holder DM Notifications: ENABLED üì®`;
      for (const adminId of ADMIN_IDS) {
        try {
          await bot.telegram.sendMessage(adminId, adminMsg, { parse_mode: 'Markdown' });
        } catch {}
      }
    } catch (e) {
      console.log(`‚ö†Ô∏è Channel not accessible: ${e.message}`);
      console.log('‚ö†Ô∏è Make sure bot is admin in the channel!');
    }
    
    console.log('üöÄ Bot fully started and ready!');
    console.log('‚úÖ ALL FIXES APPLIED:');
    console.log('  ‚Ä¢ Creator "My Tokens" panel working');
    console.log('  ‚Ä¢ Admin "Manage Tokens" FIXED (unique callback data)');
    console.log('  ‚Ä¢ Creator Stats, Report, Holder Stats, Edit Display FIXED');
    console.log('  ‚Ä¢ All action handlers implemented');
    console.log('  ‚Ä¢ New post format with CA address');
    console.log('  ‚Ä¢ Auto-migration system for database');
    console.log('üéØ CRITICAL FIX: Creator-isolated reward pools ACTIVATED');
    console.log('üì® Holder DM System: ACTIVE');
    console.log('üéØ Payouts now ONLY from creator own pool!');
    console.log('üéóÔ∏è Bonded Posting System: ACTIVATED');
    console.log('üìà Milestone Auto-Posts: 2x/5x/10x ENABLED');
    console.log('‚è∞ Auto-Payouts: 20:00 UTC daily');
    
  } catch (e) {
    console.log('‚ùå Bot start failed:', String(e?.message || e));
    console.log('üîÑ Restarting in 10 seconds...');
    setTimeout(launchBot, 10000);
  }
}

launchBot();

process.once('SIGINT', () => {
  console.log('üõë SIGINT received, stopping bot...');
  bot.stop('SIGINT');
  process.exit(0);
});

process.once('SIGTERM', () => {
  console.log('üõë SIGTERM received, stopping bot...');
  bot.stop('SIGTERM');
  process.exit(0);
});
